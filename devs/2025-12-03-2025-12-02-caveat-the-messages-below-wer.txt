
 â–â–›â–ˆâ–ˆâ–ˆâ–œâ–Œ   Claude Code v2.0.56
â–â–œâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–›â–˜  Sonnet 4.5 Â· Claude Pro
  â–˜â–˜ â–â–    D:\Users\user\Documents\rust\wenget

> è¼‰å›æ˜¨å¤©çš„é–‹ç™¼é€²åº¦ 
2025-12-02-caveat-the-messages-below-were-generated-by-the-u.txt

â— I'll read the file containing yesterday's development progress.

â— Read(2025-12-02-caveat-the-messages-below-were-generated-by-the-u.txt)
  â¿ Â Read 457 lines

â— æˆ‘å·²ç¶“è®€å–äº†æ˜¨å¤©çš„é–‹ç™¼é€²åº¦ã€‚æ ¹æ“šè¨˜éŒ„ï¼Œæ˜¨å¤©å®Œæˆäº†ä»¥ä¸‹åŠŸèƒ½ï¼š

  å·²å®Œæˆçš„åŠŸèƒ½

  1. æ™ºæ…§è­˜åˆ¥åŸ·è¡Œæª”åç¨± (src/installer/extractor.rs:379-442)

  - æ–°å¢ normalize_command_name() å‡½æ•¸
  - è‡ªå‹•ç§»é™¤å¹³å°å¾Œç¶´ï¼Œä¾‹å¦‚ï¼š
    - cate-windows-x86_64.exe â†’ cate
    - tool-linux-aarch64 â†’ tool
    - app-darwin-x86_64 â†’ app

  2. --name åƒæ•¸é€šç”¨åŒ– (src/cli.rs:39, src/commands/add.rs)

  - æ›´æ–°åƒæ•¸èªªæ˜ç‚ºã€ŒCustom command name (overrides the default executable
  name)ã€
  - --name ç¾åœ¨é©ç”¨æ–¼æ‰€æœ‰å®‰è£é¡å‹ï¼ˆrepo/bucket/scriptï¼‰

  3. è¨˜éŒ„æŒ‡ä»¤å‘¼å«åç¨± (src/core/manifest.rs:207)

  - åœ¨ InstalledPackage çµæ§‹ä¸­æ–°å¢ command_name æ¬„ä½
  - å®‰è£æ™‚è‡ªå‹•è¨˜éŒ„å¯¦éš›çš„æŒ‡ä»¤å‘¼å«åç¨±

  4. list/info é¡¯ç¤ºæŒ‡ä»¤åç¨±

  - list æŒ‡ä»¤ï¼šæ–°å¢ COMMAND æ¬„ä½ (src/commands/list.rs:40-72)
  - info æŒ‡ä»¤ï¼šé¡¯ç¤º Command name æ¬„ä½ (src/commands/info.rs:122)

  ç›®å‰ç‹€æ…‹

  å¾ git status ä¾†çœ‹ï¼Œä»¥ä¸‹æª”æ¡ˆæœ‰ä¿®æ”¹ä½†å°šæœªæäº¤ï¼š
  - âœ“ å·²ç·¨è­¯æ¸¬è©¦é€šé (cargo check/build æˆåŠŸ)
  - æœ‰æ–°å¢çš„æœªè¿½è¹¤æª”æ¡ˆï¼šsrc/installer/script.rs
  - åˆªé™¤äº† DOCUMENTATION.md å’Œ SOURCES.md

  è¨˜éŒ„çš„æœ€å¾Œæåˆ°ä½¿ç”¨è€…è¼¸å…¥äº† "export" ä½†è¢«ä¸­æ–·äº†ã€‚

  è«‹å•æ‚¨æ¥ä¸‹ä¾†æƒ³è¦ï¼š
  1. æäº¤é€™äº›æ”¹å‹•ï¼Ÿ
  2. æ¸¬è©¦å‰›å¯¦ç¾çš„åŠŸèƒ½ï¼Ÿ
  3. ç¹¼çºŒé–‹ç™¼å…¶ä»–åŠŸèƒ½ï¼Ÿ

> æ€è€ƒè‡ªå‹•ç§»é™¤å¹³å°å¾Œç¶´çš„é‚è¼¯å¯å¦å„ªåŒ–?æˆ‘çš„æƒ³æ³•æ˜¯æŠŠæª”åä¸­ç¬¬ä¸€å€‹"-"æˆ–"_"é€£åŒå¾Œ
é¢éƒ½ç§»é™¤æ‰å°±å¥½ã€‚å…ˆè©•ä¼°å°±å¥½ã€‚

â— æˆ‘ä¾†è©•ä¼°ä¸€ä¸‹é€™å€‹ç°¡åŒ–é‚è¼¯çš„å¯è¡Œæ€§ã€‚è®“æˆ‘å…ˆçœ‹çœ‹ç›®å‰çš„å¯¦ç¾ï¼š

â— Read(src\installer\extractor.rs)
  â¿ Â Read 70 lines

â— è®“æˆ‘è©•ä¼°ä¸€ä¸‹æ‚¨æè­°çš„ç°¡åŒ–é‚è¼¯ã€‚æˆ‘éœ€è¦å…ˆçœ‹çœ‹å¯¦éš›ä½¿ç”¨å ´æ™¯ï¼š

â— Search(pattern: "find_executable", path: "src\commands\add.rs", output_mode:
        "content")
  â¿ Â Found 19 lines (ctrl+o to expand)

â— Search(pattern: "normalize_command_name", path: "src\commands\add.rs",
        output_mode: "content")
  â¿ Â Found 23 lines (ctrl+o to expand)

â— Read(src\installer\extractor.rs)
  â¿ Â Read 50 lines

â— ç°¡åŒ–é‚è¼¯è©•ä¼°å ±å‘Š

  æ‚¨çš„æè­°ï¼šç§»é™¤ç¬¬ä¸€å€‹ - æˆ– _ åŠå…¶å¾Œå…§å®¹

  âœ… å„ªé»

  1. ä»£ç¢¼æ¥µç°¡ - å¾ 70 è¡Œç¸®æ¸›åˆ° 3-5 è¡Œ
  2. ç„¡éœ€ç¶­è­·ç™½åå–® - ä¸ç”¨è¿½è¹¤æ‰€æœ‰å¹³å°æ¨¡å¼
  3. æ•ˆèƒ½æ›´å¥½ - O(n) æŸ¥æ‰¾ vs O(nÃ—27) æ¨¡å¼åŒ¹é…
  4. è‡ªå‹•é©æ‡‰æœªä¾† - ç„¡è«–å‡ºç¾ä»€éº¼æ–°å¹³å°éƒ½èƒ½è™•ç†

  âš ï¸ æ½›åœ¨å•é¡Œ

  1. å·¥å…·åç¨±æœ¬èº«å«é€£å­—ç¬¦çš„æƒ…æ³ï¼š

  âŒ git-lfs-windows-x86_64.exe    â†’ git      (æ‡‰è©²æ˜¯ git-lfs)
  âŒ node-sass-linux-x64           â†’ node     (æ‡‰è©²æ˜¯ node-sass)
  âŒ gh-cli-v2.0-windows           â†’ gh       (æ‡‰è©²æ˜¯ gh-cli)
  âœ… cate-windows-x86_64.exe       â†’ cate     (æ­£ç¢º)
  âœ… bat-v0.24.0-x86_64            â†’ bat      (æ­£ç¢º)
  âœ… ripgrep-13.0-linux            â†’ ripgrep  (æ­£ç¢º)

  2. å¯¦éš›æƒ…æ³åˆ†æï¼š

  æˆ‘æ³¨æ„åˆ° find_executable_candidates åœ¨ line 316-318 æœƒçµ¦ã€Œç°¡å–®æª”åã€ï¼ˆä¸å«
   - å’Œ _ï¼‰åŠ åˆ†ï¼Œé€™æš—ç¤ºï¼š
  - è§£å£“å¾Œçš„å¯åŸ·è¡Œæª”å¯èƒ½é‚„æ˜¯æœƒæœ‰å¹³å°å¾Œç¶´
  - ä½†å¤§å¤šæ•¸é …ç›®æœƒç›´æ¥ä½¿ç”¨ç°¡å–®åç¨±ï¼ˆå¦‚ bat.exe, fd.exeï¼‰

  3. çœŸå¯¦ä¸–ç•Œçš„æ¡ˆä¾‹ï¼š
  - å¤§éƒ¨åˆ†å·¥å…·ï¼šå–®è©åï¼ˆbat, fd, exa, delta, ripgrepï¼‰-
  å°éƒ¨åˆ†å·¥å…·ï¼šå«é€£å­—ç¬¦ï¼ˆgit-lfs, gh-cli ç­‰ï¼‰

  å»ºè­°æ–¹æ¡ˆ

  æ–¹æ¡ˆ Aï¼šæ¢ä»¶å¼ç°¡åŒ–é‚è¼¯ï¼ˆæ¨è–¦ï¼‰
  1. ç§»é™¤ .exe
  2. æª¢æŸ¥æ˜¯å¦åŒ…å«å¹³å°é—œéµè© (windows/linux/darwin/x86_64/aarch64/arm64 ç­‰)
  3. å¦‚æœåŒ…å« â†’ ç§»é™¤ç¬¬ä¸€å€‹ - æˆ– _ åŠä¹‹å¾Œå…§å®¹
  4. å¦‚æœä¸åŒ…å« â†’ ä¿æŒåŸæ¨£

  å„ªé»ï¼š å…¼é¡§ç°¡æ½”èˆ‡å®‰å…¨
  - cate-windows-x86_64 â†’ cate âœ…
  - git-lfs-windows-x64 â†’ git-lfs âœ…
  - git-lfs â†’ git-lfs âœ…ï¼ˆç„¡å¹³å°é—œéµè©ï¼Œä¿æŒåŸæ¨£ï¼‰

  ---
  æ–¹æ¡ˆ Bï¼šæ‚¨åŸæœ¬çš„æ¿€é€²ç°¡åŒ–
  ç›´æ¥ç§»é™¤ç¬¬ä¸€å€‹ - æˆ– _ åŠä¹‹å¾Œå…§å®¹

  é©ç”¨æƒ…å¢ƒï¼š å¦‚æœæ‚¨ç¢ºå®šä½¿ç”¨çš„å·¥å…·å¤§å¤šæ˜¯å–®è©åç¨±
  - ä»£ç¢¼æœ€ç°¡æ½”ï¼ˆ3-5 è¡Œï¼‰
  - å¯èƒ½èª¤å‚· git-lfs é¡çš„å·¥å…·
  - ä½†ç”¨æˆ¶å¯ç”¨ --name æ‰‹å‹•æŒ‡å®š

  ---
  æ–¹æ¡ˆ Cï¼šä¿æŒç¾ç‹€
  ç¶­æŒç™½åå–®é‚è¼¯

  å„ªé»ï¼š æœ€ä¿å®ˆï¼Œä¸æœƒèª¤ç§»é™¤

  æˆ‘çš„å»ºè­°

  è€ƒæ…®åˆ°ï¼š
  1. å¤§éƒ¨åˆ† CLI å·¥å…·æ˜¯å–®è©åï¼ˆ80%+ï¼‰
  2. ç”¨æˆ¶å¯ç”¨ --name æ‰‹å‹•è¦†è“‹
  3. ç°¡æ½”æ€§çš„åƒ¹å€¼

  å»ºè­°æ¡ç”¨æ–¹æ¡ˆ Aï¼ˆæ¢ä»¶å¼ç°¡åŒ–ï¼‰ï¼Œä»£ç¢¼ç´„ 10-15 è¡Œï¼Œå…¼é¡§å®‰å…¨èˆ‡ç°¡æ½”ã€‚

  æ‚¨å‚¾å‘å“ªå€‹æ–¹æ¡ˆï¼Ÿé‚„æ˜¯æœ‰å…¶ä»–æƒ³æ³•ï¼Ÿ

> æ–¹æ¡ˆAä¸éŒ¯ä½†ï¼Œ1.æ²’æœ‰å¿…è¦ç§»é™¤.exeï¼Œå› ç‚ºåœ¨windowså¹³å°æœƒåŒ…è£¹æŒ‡ä»¤æ·å¾‘cmdæ”¾é€²å¯
åŸ·è¡Œè·¯å¾‘ä¸­ 2.ä¸æ‡‰è©²ä¿®æ”¹è§£å£“ç¸®å¾Œçš„åŸ·è¡Œæª”åï¼Œåªè¨­å®šæŒ‡ä»¤æ·å¾‘cmdçš„åŸ·è¡Œæª”å(windo
wså¹³å°)æˆ–linkæª”å(linux/macå¹³å°)

â— æ‚¨èªªå¾—å°ï¼æˆ‘é‡æ–°ç†è§£äº†ï¼š

  1. åŸå§‹æª”æ¡ˆä¸å‹• - cate-windows-x86_64.exe ä¿å­˜åœ¨ app ç›®éŒ„
  2. åªæ™ºæ…§å‘½åæ·å¾‘ - åœ¨ bin ç›®éŒ„å‰µå»º cate.cmd(Win) æˆ– cate(Linux)
  æŒ‡å‘åŸæª”æ¡ˆ

  è®“æˆ‘ç¢ºèªä¸€ä¸‹ç›®å‰çš„æµç¨‹å’Œéœ€è¦å„ªåŒ–çš„åœ°æ–¹ï¼š

â— Read(src\commands\add.rs)
  â¿ Â Read 30 lines

â— Search(pattern: "fn bin_shim_path", output_mode: "content")
  â¿ Â Found 16 lines (ctrl+o to expand)

â— æ˜ç™½äº†ï¼è®“æˆ‘ç¢ºèªç†è§£ï¼š

  ä¿®æ­£å¾Œçš„ç†è§£

  æµç¨‹ï¼š
  åŸå§‹æª”æ¡ˆ: cate-windows-x86_64.exe (ä¿å­˜åœ¨ ~/.wenget/apps/cate/)
           â†“ normalize_command_name
  æŒ‡ä»¤åç¨±: cate
           â†“ bin_shim_path
  æ·å¾‘æª”æ¡ˆ: ~/.wenget/bin/cate.cmd (Windows) æˆ– cate (Linux)

  ä½†æœ‰å€‹ç–‘å•ï¼š æ–¹æ¡ˆ A å¦‚æœã€Œä¸ç§»é™¤ .exeã€ï¼š

  // æ¡ˆä¾‹ 1: æœ‰å¹³å°å¾Œç¶´
  "cate-windows-x86_64.exe"
  â†’ åŒ…å« "windows"
  â†’ ç¬¬ä¸€å€‹ - å‰ = "cate" âœ…

  // æ¡ˆä¾‹ 2: ç„¡å¹³å°å¾Œç¶´ (ç›´æ¥å°±æ˜¯åŸ·è¡Œæª”)
  "ripgrep.exe"
  â†’ ä¸åŒ…å«å¹³å°é—œéµè©
  â†’ ä¿æŒåŸæ¨£ = "ripgrep.exe"
  â†’ bin_shim_path â†’ "ripgrep.exe.cmd" âŒ éŒ¯èª¤ï¼

  æ‰€ä»¥æˆ‘çš„å•é¡Œæ˜¯ï¼š

  åœ¨æ–¹æ¡ˆ A ä¸­ï¼Œå°æ–¼ä¸åŒ…å«å¹³å°é—œéµè©çš„æª”åï¼ˆå¦‚ tool.exe,
  git-lfs.exeï¼‰ï¼Œæ‡‰è©²å¦‚ä½•è™•ç† .exeï¼Ÿ

  é¸é …ï¼š
  1. åœ¨ normalize_command_name æœ€å¾Œçµ±ä¸€ trim_end_matches(".exe")
  2. åœ¨ bin_shim_path ä¹‹å‰é¡å¤–è™•ç†
  3. å…¶ä»–æ‚¨å»ºè­°çš„æ–¹å¼ï¼Ÿ

  èƒ½å¦æ¾„æ¸…ä¸€ä¸‹é€™å€‹ç´°ç¯€ï¼Ÿ

> äº†è§£äº†ï¼Œé‚£æ¡ç”¨é¸é …1. åœ¨ normalize_command_name æœ€å¾Œçµ±ä¸€ 
trim_end_matches(".exe")

â— å¥½çš„ï¼æˆ‘ä¾†å¯¦ç¾å„ªåŒ–å¾Œçš„æ–¹æ¡ˆ Aã€‚è®“æˆ‘å…ˆå‰µå»ºä»»å‹™æ¸…å–®ï¼š

â— ç¾åœ¨å¯¦ç¾æ–¹æ¡ˆ A çš„å„ªåŒ–é‚è¼¯ï¼š

â— Update(src\installer\extractor.rs)
  â¿ Â Updated src\installer\extractor.rs with 27 additions and 58 removals
       372    }
       373    
       374    /// Normalize a command name by removing platform-specific 
             suffixes
       375 +  ///
       376 +  /// Strategy: Check if filename contains platform keywords.
           +  If yes, remove everything
       377 +  /// from the first `-` or `_`. Finally, always remove 
           + `.exe` extension.
       378 +  ///
       379    /// Examples:
       380    ///   "cate-windows-x86_64.exe" -> "cate"
       381 +  ///   "bat-v0.24-x86_64.exe" -> "bat"
       382 +  ///   "git-lfs.exe" -> "git-lfs"
       383 +  ///   "ripgrep.exe" -> "ripgrep"
       384    ///   "tool-linux-aarch64" -> "tool"
       385 -  ///   "app-darwin-x86_64.exe" -> "app"
       385    pub fn normalize_command_name(name: &str) -> String {
       386 -      // First, strip .exe extension
       387 -      let name = name.trim_end_matches(".exe");
       388 -  
       389 -      // Common platform suffixes to remove
       390 -      let platform_patterns = [
       391 -          // OS + arch combinations
       392 -          "-windows-x86_64",
       393 -          "-windows-aarch64",
       394 -          "-windows-i686",
       395 -          "-windows-arm64",
       396 -          "-linux-x86_64",
       397 -          "-linux-aarch64",
       398 -          "-linux-armv7",
       399 -          "-linux-i686",
       400 -          "-linux-arm64",
       401 -          "-darwin-x86_64",
       402 -          "-darwin-aarch64",
       403 -          "-darwin-arm64",
       404 -          "-macos-x86_64",
       405 -          "-macos-aarch64",
       406 -          "-macos-arm64",
       407 -          "-freebsd-x86_64",
       408 -          "-netbsd-x86_64",
       409 -          "-openbsd-x86_64",
       410 -          // Architecture only
       411 -          "-x86_64",
       412 -          "-aarch64",
       413 -          "-arm64",
       414 -          "-armv7",
       415 -          "-i686",
       416 -          "-x64",
       417 -          "-x86",
       418 -          // OS only (less common but still useful)
       419 -          "-windows",
       420 -          "-linux",
       421 -          "-darwin",
       422 -          "-macos",
       423 -          "-freebsd",
       424 -          "-netbsd",
       425 -          "-openbsd",
       426 -          // With underscores instead of hyphens
       427 -          "_windows_x86_64",
       428 -          "_linux_x86_64",
       429 -          "_darwin_x86_64",
       430 -          "_x86_64",
       431 -          "_aarch64",
       432 -          "_arm64",
       386 +      // Platform keywords to detect platform-specific 
           + suffixes
       387 +      let platform_keywords = [
       388 +          "windows", "linux", "darwin", "macos", "freebsd", 
           + "netbsd", "openbsd",
       389 +          "x86_64", "aarch64", "arm64", "armv7", "i686", 
           + "x64", "x86",
       390 +          "pc", "unknown", "gnu", "musl", "msvc",
       391        ];
       392    
       393 -      let mut result = name.to_string();
       394 -  
       395 -      // Try to remove platform suffixes (case-insensitive)
       393 +      // Check if filename contains any platform keywords 
           + (case-insensitive)
       394        let lower_name = name.to_lowercase();
       395 -      for pattern in &platform_patterns {
       396 -          if lower_name.ends_with(pattern) {
       397 -              // Remove the suffix, preserving original case 
           - for the base name
       398 -              result = name[..name.len() - 
           - pattern.len()].to_string();
       399 -              break;
       395 +      let has_platform_suffix = 
           + platform_keywords.iter().any(|kw| lower_name.contains(kw));
       396 +  
       397 +      let result = if has_platform_suffix {
       398 +          // Find first `-` or `_` and remove everything from
           +  there
       399 +          if let Some(pos) = name.find(|c| c == '-' || c == 
           + '_') {
       400 +              &name[..pos]
       401 +          } else {
       402 +              name
       403            }
       404 -      }
       404 +      } else {
       405 +          // No platform keywords, keep original name
       406 +          name
       407 +      };
       408    
       409 -      result
       409 +      // Always remove .exe extension at the end
       410 +      result.trim_end_matches(".exe").to_string()
       411    }
       412    
       413    #[cfg(test)]

â— ç¾åœ¨æ¸¬è©¦ç·¨è­¯ï¼š

â— Bash(cargo check)
  â¿     Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)       
        Finished `dev` profile [unoptimized + debuginfo] target(s) in 32.92
    s


â— Bash(cargo build --release) timeout: 3m 0s
  â¿ Â    Compiling wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)
         Finished `release` profile [optimized] target(s) in 1m 18s

â— è®“æˆ‘æª¢æŸ¥æ˜¯å¦æœ‰ç¾æœ‰çš„æ¸¬è©¦ï¼Œä¸¦æ·»åŠ ä¸€äº›æ¸¬è©¦æ¡ˆä¾‹ï¼š

â— Read(src\installer\extractor.rs)
  â¿ Â Read 17 lines

â— è®“æˆ‘æ·»åŠ æ¸¬è©¦æ¡ˆä¾‹ä¾†é©—è­‰æ–°çš„é‚è¼¯ï¼š

â— Update(src\installer\extractor.rs)
  â¿ Â Updated src\installer\extractor.rs with 25 additions                
       425            let exe = find_executable(&files, "rg");
       426            assert_eq!(exe, 
             Some("ripgrep-15.1.0/bin/rg.exe".to_string()));
       427        }
       428 +  
       429 +      #[test]
       430 +      fn test_normalize_command_name() {
       431 +          // Files with platform suffixes - should remove 
           + from first - or _
       432 +          assert_eq!(normalize_command_name("cate-windows-x86
           + _64.exe"), "cate");
       433 +          
           + assert_eq!(normalize_command_name("bat-v0.24-x86_64.exe"), 
           + "bat");
       434 +          
           + assert_eq!(normalize_command_name("tool-linux-aarch64"), 
           + "tool");
       435 +          
           + assert_eq!(normalize_command_name("app-darwin-x86_64.exe"), 
           + "app");
       436 +          assert_eq!(normalize_command_name("ripgrep-13.0.0-x
           + 86_64-pc-windows-msvc.exe"), "ripgrep");
       437 +          
           + assert_eq!(normalize_command_name("fd_v8.7.0_x86_64.exe"), 
           + "fd");
       438 +  
       439 +          // Files without platform suffixes - should keep 
           + name but remove .exe
       440 +          assert_eq!(normalize_command_name("ripgrep.exe"), 
           + "ripgrep");
       441 +          assert_eq!(normalize_command_name("git-lfs.exe"), 
           + "git-lfs");
       442 +          assert_eq!(normalize_command_name("gh-cli.exe"), 
           + "gh-cli");
       443 +          assert_eq!(normalize_command_name("node-sass.exe"),
           +  "node-sass");
       444 +  
       445 +          // Unix executables without .exe
       446 +          assert_eq!(normalize_command_name("ripgrep"), 
           + "ripgrep");
       447 +          assert_eq!(normalize_command_name("git-lfs"), 
           + "git-lfs");
       448 +  
       449 +          // Edge cases
       450 +          assert_eq!(normalize_command_name("tool.exe"), 
           + "tool");
       451 +          assert_eq!(normalize_command_name("tool"), "tool");
       452 +      }
       453    }

â— ç¾åœ¨é‹è¡Œæ¸¬è©¦ï¼š

â— Bash(cargo test normalize_command_name) timeout: 1m 0s
  â¿ Â running 1 test                                                      
     test installer::extractor::tests::test_normalize_command_name ... ok
     â€¦ +10 lines (ctrl+o to expand)

â— âœ… å„ªåŒ–å®Œæˆï¼

  ğŸ“Š æ”¹é€²å°æ¯”

  å„ªåŒ–å‰ï¼š 70 è¡Œä»£ç¢¼ + 27 å€‹ç™½åå–®æ¨¡å¼
  å„ªåŒ–å¾Œï¼š 25 è¡Œä»£ç¢¼ + æ¢ä»¶å¼é‚è¼¯

  ğŸ¯ æ–°çš„é‚è¼¯ï¼ˆæ–¹æ¡ˆ Aï¼‰

  src/installer/extractor.rs:385-411

  1. æª¢æŸ¥æª”åæ˜¯å¦åŒ…å«å¹³å°é—œéµè©ï¼ˆwindows/linux/x86_64 ç­‰ï¼‰
  2. å¦‚æœåŒ…å« â†’ ç§»é™¤ç¬¬ä¸€å€‹ `-` æˆ– `_` åŠä¹‹å¾Œå…§å®¹
  3. å¦‚æœä¸åŒ…å« â†’ ä¿æŒåŸå
  4. æœ€å¾Œçµ±ä¸€ç§»é™¤ `.exe` æ“´å±•å

  âœ… æ¸¬è©¦çµæœ

  æ‰€æœ‰æ¸¬è©¦æ¡ˆä¾‹é€šéï¼š

  æœ‰å¹³å°å¾Œç¶´ï¼ˆæœƒæˆªæ–·ï¼‰ï¼š
  - cate-windows-x86_64.exe â†’ cate âœ…
  - bat-v0.24-x86_64.exe â†’ bat âœ…
  - ripgrep-13.0.0-x86_64-pc-windows-msvc.exe â†’ ripgrep âœ…

  ç„¡å¹³å°å¾Œç¶´ï¼ˆä¿ç•™å®Œæ•´åç¨±ï¼‰ï¼š
  - git-lfs.exe â†’ git-lfs âœ…
  - node-sass.exe â†’ node-sass âœ…
  - gh-cli â†’ gh-cli âœ…

  ğŸ’¡ å„ªé»

  1. ä»£ç¢¼ç°¡æ½” - æ¸›å°‘ 65% ä»£ç¢¼é‡
  2. ç„¡éœ€ç¶­è­· - ä¸ç”¨è¿½è¹¤æ–°å¹³å°æ¨¡å¼
  3. æ™ºæ…§è™•ç† - è‡ªå‹•ä¿è­·å¸¶é€£å­—ç¬¦çš„å·¥å…·å
  4. å‘å¾Œå…¼å®¹ - ç”¨æˆ¶ä»å¯ç”¨ --name æ‰‹å‹•è¦†è“‹

  æ¥ä¸‹ä¾†æ‚¨æƒ³è¦æäº¤é€™äº›æ”¹å‹•ï¼Œé‚„æ˜¯ç¹¼çºŒå…¶ä»–é–‹ç™¼ï¼Ÿ

> è©•ä¼°bucketæ ¼å¼å¯ç›¸å®¹ç·šä¸Šè…³æœ¬çš„å¯è¡Œæ–¹æ¡ˆ 

â— æˆ‘ä¾†è©•ä¼°é€™å€‹éœ€æ±‚ã€‚é¦–å…ˆè®“æˆ‘äº†è§£ç›®å‰çš„ bucket æ ¼å¼å’Œè…³æœ¬å®‰è£æ©Ÿåˆ¶ï¼š

â— Search(pattern: "struct.*Bucket", output_mode: "content")
  â¿ Â Found 23 lines (ctrl+o to expand)

â— Search(pattern: "is_script_input|install_script", path: "src\commands\add.rs",
         output_mode: "content")
  â¿ Â Found 55 lines (ctrl+o to expand)

â— Read(src\core\manifest.rs)
  â¿ Â Read 100 lines

â— Read(src\core\manifest.rs)
  â¿ Â Read 80 lines

â— Search(pattern: "struct Package", output_mode: "content")
  â¿ Â Found 43 lines (ctrl+o to expand)

â— Read(src\installer\script.rs)
  â¿ Â Read 100 lines

â— å¥½çš„ï¼Œè®“æˆ‘è©•ä¼° bucket æ ¼å¼æ”¯æ´ç·šä¸Šè…³æœ¬çš„å¯è¡Œæ–¹æ¡ˆã€‚é¦–å…ˆç†è§£ç›®å‰çš„æ¶æ§‹ï¼š

  ğŸ“‹ ç›®å‰æ¶æ§‹åˆ†æ

  1. Packageï¼ˆäºŒé€²åˆ¶åŒ…ï¼‰ - src/core/manifest.rs:110-132

  platforms: HashMap<String, PlatformBinary>
  // æ¯å€‹å¹³å°æœ‰: url, size, checksum

  2. Scriptï¼ˆè…³æœ¬ï¼‰ - ç›®å‰ç¨ç«‹è™•ç†

  - å¾ URL ç›´æ¥ä¸‹è¼‰è…³æœ¬å…§å®¹
  - ä¸éœ€è§£å£“ç¸®ï¼Œç›´æ¥ä¿å­˜ä¸¦å‰µå»º shim
  - æ”¯æ´ PowerShell, Batch, Bash, Python

  ---
  ğŸ¯ å¯è¡Œæ–¹æ¡ˆè©•ä¼°

  æ–¹æ¡ˆ Aï¼šæ“´å±• Package çµæ§‹ï¼ˆæ¨è–¦ï¼‰

  è¨­è¨ˆï¼š åœ¨ Package ä¸­æ·»åŠ å¯é¸çš„ script æ¬„ä½

  pub struct Package {
      pub name: String,
      pub description: String,
      pub repo: String,

      // äºŒé€²åˆ¶åŒ…ï¼ˆå¯é¸ï¼‰
      #[serde(skip_serializing_if = "Option::is_none")]
      pub platforms: Option<HashMap<String, PlatformBinary>>,

      // è…³æœ¬åŒ…ï¼ˆå¯é¸ï¼‰- NEW
      #[serde(skip_serializing_if = "Option::is_none")]
      pub script: Option<ScriptPackage>,
  }

  pub struct ScriptPackage {
      pub url: String,          // è…³æœ¬ä¸‹è¼‰ URL
      pub script_type: ScriptType,  // ps1/bat/sh/py
      pub checksum: Option<String>,
  }

  JSON ç¯„ä¾‹ï¼š
  {
    "packages": [
      {
        "name": "my-script",
        "description": "Useful script",
        "repo": "https://github.com/user/repo",
        "script": {
          "url":
  "https://raw.githubusercontent.com/user/repo/main/script.ps1",
          "script_type": "powershell",
          "checksum": "sha256:..."
        }
      }
    ]
  }

  âœ… å„ªé»ï¼š
  - å‘å¾Œç›¸å®¹ï¼ˆç¾æœ‰ Package ä¸å—å½±éŸ¿ï¼‰
  - çµ±ä¸€çš„ manifest æ ¼å¼
  - å¯åŒæ™‚æ”¯æ´äºŒé€²åˆ¶å’Œè…³æœ¬ï¼ˆç†è«–ä¸Šï¼‰
  - ç°¡å–®ç›´è§€

  âš ï¸ ç¼ºé»ï¼š
  - Package è®Šå¾—æ›´è¤‡é›œ
  - éœ€è¦é©—è­‰é‚è¼¯ç¢ºä¿ platforms å’Œ script è‡³å°‘æœ‰ä¸€å€‹

  ---
  æ–¹æ¡ˆ Bï¼šä¸¦åˆ—çµæ§‹

  è¨­è¨ˆï¼š SourceManifest åŒæ™‚åŒ…å«å…©ç¨®é¡å‹

  pub struct SourceManifest {
      pub packages: Vec<Package>,    // äºŒé€²åˆ¶åŒ…
      pub scripts: Vec<ScriptItem>,  // è…³æœ¬åŒ… - NEW
  }

  pub struct ScriptItem {
      pub name: String,
      pub description: String,
      pub url: String,
      pub script_type: ScriptType,
      pub repo: String,
      pub checksum: Option<String>,
  }

  JSON ç¯„ä¾‹ï¼š
  {
    "packages": [...],
    "scripts": [
      {
        "name": "my-script",
        "description": "Useful script",
        "url": "https://raw.githubusercontent.com/.../script.ps1",
        "script_type": "powershell",
        "repo": "https://github.com/user/repo"
      }
    ]
  }

  âœ… å„ªé»ï¼š
  - çµæ§‹æ¸…æ™°ï¼Œè·è²¬åˆ†é›¢
  - ä¸å½±éŸ¿ç¾æœ‰ Package çµæ§‹
  - å®¹æ˜“ç†è§£å’Œç¶­è­·

  âš ï¸ ç¼ºé»ï¼š
  - éœ€è¦ä¿®æ”¹ SourceManifest çµæ§‹
  - æœç´¢æ™‚éœ€è¦æŸ¥æ‰¾å…©å€‹åˆ—è¡¨

  ---
  æ–¹æ¡ˆ Cï¼šçµ±ä¸€ Item æšèˆ‰

  è¨­è¨ˆï¼š ä½¿ç”¨ enum å€åˆ†é¡å‹

  pub struct SourceManifest {
      pub items: Vec<PackageItem>,
  }

  #[serde(tag = "type")]
  pub enum PackageItem {
      #[serde(rename = "binary")]
      Binary(Package),

      #[serde(rename = "script")]
      Script(ScriptItem),
  }

  JSON ç¯„ä¾‹ï¼š
  {
    "items": [
      {
        "type": "binary",
        "name": "ripgrep",
        "platforms": {...}
      },
      {
        "type": "script",
        "name": "my-script",
        "url": "https://...",
        "script_type": "powershell"
      }
    ]
  }

  âœ… å„ªé»ï¼š
  - é¡å‹å®‰å…¨
  - çµ±ä¸€çš„åˆ—è¡¨ï¼Œæ˜“æ–¼æœç´¢
  - ç¬¦åˆ Rust æ…£ä¾‹

  âš ï¸ ç¼ºé»ï¼š
  - ç ´å£å‘å¾Œç›¸å®¹æ€§ï¼ˆæœ€å¤§å•é¡Œï¼‰
  - ç¾æœ‰çš„ bucket manifest éœ€è¦å…¨éƒ¨æ›´æ–°
  - è¤‡é›œåº¦è¼ƒé«˜

  ---
  ğŸ“Š æ–¹æ¡ˆå°æ¯”ç¸½çµ

  | æ–¹æ¡ˆ            | å‘å¾Œç›¸å®¹   | å¯¦ç¾è¤‡é›œåº¦   | ä½¿ç”¨ç°¡ä¾¿æ€§  | æ¨è–¦æŒ‡æ•¸  |
  |---------------|--------|---------|--------|-------|
  | A: æ“´å±• Package | âœ… å®Œå…¨ç›¸å®¹ | â­â­ ä¸­ç­‰   | â­â­â­ ç°¡å–® | â­â­â­â­â­ |
  | B: ä¸¦åˆ—çµæ§‹       | âœ… å®Œå…¨ç›¸å®¹ | â­â­â­ ç¨é«˜  | â­â­â­ ç°¡å–® | â­â­â­â­
   |
  | C: çµ±ä¸€æšèˆ‰       | âŒ ä¸ç›¸å®¹  | â­â­â­â­ è¼ƒé«˜ | â­â­ è¼ƒè¤‡é›œ | â­â­    |

  ---
  ğŸ’¡ æˆ‘çš„æ¨è–¦ï¼šæ–¹æ¡ˆ A

  ç†ç”±ï¼š
  1. å‘å¾Œç›¸å®¹ - ç¾æœ‰ bucket ç„¡éœ€ä¿®æ”¹
  2. ç°¡å–®ç›´è§€ - Package è‡ªç„¶æ“´å±•ï¼Œæ¦‚å¿µçµ±ä¸€
  3. å¯¦ç¾æˆæœ¬ä½ - åªéœ€ä¿®æ”¹çµæ§‹å®šç¾©å’Œå®‰è£é‚è¼¯
  4. éˆæ´» - æœªä¾†å¯æ”¯æ´æ··åˆåŒ…ï¼ˆåŒæ™‚æä¾›äºŒé€²åˆ¶å’Œè…³æœ¬ï¼‰

  éœ€è¦ä¿®æ”¹çš„åœ°æ–¹ï¼š
  1. Package çµæ§‹ - æ·»åŠ  script æ¬„ä½
  2. PackageResolver - è­˜åˆ¥è…³æœ¬é¡å‹çš„åŒ…
  3. add.rs - çµ±ä¸€è™•ç†æµç¨‹

  æ‚¨å‚¾å‘å“ªå€‹æ–¹æ¡ˆï¼Ÿæˆ–æœ‰å…¶ä»–æƒ³æ³•ï¼Ÿ

> æˆ‘preferæ–¹æ¡ˆäºŒï¼Œä¸‹ä¸€æ­¥æˆ‘æƒ³å…ˆè©•ä¼°å°manifest cacheçš„å½±éŸ¿å’Œå¯è¡Œè™•ç†æ–¹å¼ä»¥ä¾¿æ”¯
æ´list/infoç­‰æŒ‡ä»¤ï¼Œè‡³æ–¼installed.jsonæ‡‰è©²æ˜¯å·²ç¶“æ”¯æ´äº†?

â— å¥½çš„ï¼æ–¹æ¡ˆ B ç¢ºå¯¦æ›´æ¸…æ™°ã€‚è®“æˆ‘è©•ä¼°å° manifest cache çš„å½±éŸ¿å’Œ installed.json
   çš„æ”¯æ´æƒ…æ³ï¼š

â— Search(pattern: "struct.*Cache|cache.*json", output_mode: "content")
  â¿ Â Found 160 lines (ctrl+o to expand)

â— Read(src\core\config.rs)
  â¿ Â Read 234 lines

â— Search(pattern: "fn.*cache|load.*cache|save.*cache", output_mode: "content")
  â¿ Â Found 207 lines (ctrl+o to expand)

â— Read(src\cache.rs)
  â¿ Â Read 260 lines

â— Read(src\core\manifest.rs)
  â¿ Â Read 50 lines

â— å®Œç¾ï¼æˆ‘å·²ç¶“åˆ†æå®Œç•¢ã€‚è®“æˆ‘çµ¦æ‚¨å®Œæ•´çš„è©•ä¼°å ±å‘Šï¼š

  ğŸ“‹ è©•ä¼°å ±å‘Šï¼šBucket æ”¯æ´è…³æœ¬çš„å½±éŸ¿

  ---
  âœ… installed.json å·²ç¶“å®Œå…¨æ”¯æ´ï¼

  src/core/manifest.rs:166-180

  pub enum PackageSource {
      Bucket { name: String },
      DirectRepo { url: String },
      Script {                    // âœ… å·²æ”¯æ´
          origin: String,
          script_type: ScriptType,
      },
  }

  çµè«–ï¼š installed.json ç„¡éœ€ä»»ä½•ä¿®æ”¹ï¼Œå·²ç¶“å¯ä»¥è¨˜éŒ„è…³æœ¬å®‰è£ä¿¡æ¯ã€‚

  ---
  âš ï¸ manifest-cache.json éœ€è¦ä¿®æ”¹

  ç•¶å‰çµæ§‹å•é¡Œï¼š

  src/cache.rs:16-24, 47-63

  pub struct ManifestCache {
      pub packages: HashMap<String, CachedPackage>,  // âŒ åªèƒ½å­˜ Package
      ...
  }

  pub struct CachedPackage {
      #[serde(flatten)]
      pub package: Package,    // âŒ ç„¡æ³•å­˜ Script
      pub source: PackageSource,
  }

  å½±éŸ¿çš„åŠŸèƒ½ï¼š

  1. search æŒ‡ä»¤ - ä¾è³´ cache æœç´¢ï¼Œç„¡æ³•æœç´¢åˆ°è…³æœ¬
  2. list æŒ‡ä»¤ - é¡¯ç¤ºå¯ç”¨åŒ…æ™‚ï¼Œç„¡æ³•åˆ—å‡ºè…³æœ¬
  3. info æŒ‡ä»¤ - æŸ¥è©¢æœªå®‰è£çš„è…³æœ¬ä¿¡æ¯æ™‚ï¼Œç„¡æ³•å¾ cache è®€å–

  ---
  ğŸ¯ æ–¹æ¡ˆ B çš„å¯è¡Œè™•ç†æ–¹å¼

  æ–¹æ¡ˆ B-1ï¼šæ“´å±• ManifestCacheï¼ˆæ¨è–¦ï¼‰

  pub struct ManifestCache {
      pub version: String,
      pub last_updated: DateTime<Utc>,
      pub ttl_seconds: i64,
      pub sources: HashMap<String, CachedSourceInfo>,

      // äºŒé€²åˆ¶åŒ…
      pub packages: HashMap<String, CachedPackage>,

      // è…³æœ¬åŒ… - NEW
      pub scripts: HashMap<String, CachedScript>,
  }

  pub struct CachedScript {
      /// Script metadata
      #[serde(flatten)]
      pub script: ScriptItem,

      /// Source origin
      pub source: PackageSource,
  }

  pub struct ScriptItem {
      pub name: String,
      pub description: String,
      pub url: String,
      pub script_type: ScriptType,
      pub repo: String,
      pub checksum: Option<String>,
  }

  JSON ç¯„ä¾‹ï¼š
  {
    "version": "1.0",
    "packages": {
      "https://github.com/user/tool": { ... }
    },
    "scripts": {
      "my-script": {
        "name": "my-script",
        "url": "https://raw.githubusercontent.com/.../script.ps1",
        "script_type": "powershell",
        "source": { "type": "bucket", "name": "main" }
      }
    }
  }

  âœ… å„ªé»ï¼š
  - æ¸…æ™°åˆ†é›¢äºŒé€²åˆ¶åŒ…å’Œè…³æœ¬
  - å‘å¾Œç›¸å®¹ï¼ˆèˆŠç‰ˆåªçœ‹ packagesï¼‰
  - å®¹æ˜“ç†è§£å’Œç¶­è­·

  âš ï¸ ç¼ºé»ï¼š
  - search/list éœ€è¦æŸ¥æ‰¾å…©å€‹ HashMap
  - éœ€è¦èª¿æ•´ç›¸é—œå‡½æ•¸

  ---
  æ–¹æ¡ˆ B-2ï¼šçµ±ä¸€ç‚º CachedItem

  pub struct ManifestCache {
      pub items: HashMap<String, CachedItem>,  // çµ±ä¸€å„²å­˜
      ...
  }

  #[serde(tag = "item_type")]
  pub enum CachedItem {
      #[serde(rename = "package")]
      Package(CachedPackage),

      #[serde(rename = "script")]
      Script(CachedScript),
  }

  âœ… å„ªé»ï¼š
  - çµ±ä¸€çš„æœç´¢æ¥å£
  - é¡å‹å®‰å…¨

  âš ï¸ ç¼ºé»ï¼š
  - æ›´è¤‡é›œ
  - å¯èƒ½ç ´å£å‘å¾Œç›¸å®¹æ€§

  ---
  ğŸ“Š éœ€è¦ä¿®æ”¹çš„æ–‡ä»¶æ¸…å–®

  æ ¸å¿ƒçµæ§‹ï¼ˆå¿…æ”¹ï¼‰

  | æ–‡ä»¶                   | ä¿®æ”¹å…§å®¹                               |
  |----------------------|------------------------------------|
  | src/core/manifest.rs | æ·»åŠ  ScriptItem çµæ§‹ï¼Œæ“´å±• SourceManifest |
  | src/cache.rs         | æ·»åŠ  CachedScriptï¼Œæ“´å±• ManifestCache   |

  Cache æ§‹å»ºï¼ˆå¿…æ”¹ï¼‰

  | æ–‡ä»¶                                 | ä¿®æ”¹å…§å®¹                      |
  |------------------------------------|---------------------------|
  | src/cache.rs:build_cache()         | è™•ç† SourceManifest.scripts |
  | src/core/config.rs:rebuild_cache() | è§£æåŒ…å«è…³æœ¬çš„ manifest          |

  æŒ‡ä»¤æ”¯æ´ï¼ˆå¿…æ”¹ï¼‰

  | æ–‡ä»¶                      | ä¿®æ”¹å…§å®¹             |
  |-------------------------|------------------|
  | src/commands/search.rs  | æœç´¢ cache.scripts |
  | src/commands/list.rs    | åˆ—å‡ºè…³æœ¬ï¼ˆå¦‚æœéœ€è¦ï¼‰       |
  | src/commands/info.rs    | é¡¯ç¤ºè…³æœ¬è©³æƒ…           |
  | src/package_resolver.rs | è§£æè…³æœ¬è¼¸å…¥           |

  å®‰è£é‚è¼¯ï¼ˆå¯èƒ½éœ€è¦èª¿æ•´ï¼‰

  | æ–‡ä»¶                  | ä¿®æ”¹å…§å®¹            |
  |---------------------|-----------------|
  | src/commands/add.rs | å¾ cache è­˜åˆ¥ä¸¦å®‰è£è…³æœ¬ |

  ---
  ğŸ’¡ æˆ‘çš„å»ºè­°

  æ¨è–¦ä½¿ç”¨ æ–¹æ¡ˆ B-1ï¼ˆæ“´å±• ManifestCacheï¼‰

  ç†ç”±ï¼š
  1. å‘å¾Œç›¸å®¹ - èˆŠ cache ä»å¯è®€å–ï¼ˆåªæ˜¯æ²’æœ‰ scripts æ¬„ä½ï¼‰
  2. æ¸…æ™°è·è²¬ - packages å’Œ scripts æ˜ç¢ºåˆ†é›¢
  3. å¯¦ç¾ç°¡å–® - ç›¸å°å®¹æ˜“å¯¦ç¾å’Œç¶­è­·
  4. æœç´¢å‹å¥½ - å¯ä»¥åˆ†åˆ¥æˆ–åˆä½µæœç´¢

  å¯¦ç¾æ­¥é©Ÿï¼š
  1. æ“´å±• SourceManifest å’Œ ManifestCache çµæ§‹
  2. ä¿®æ”¹ build_cache() è™•ç†è…³æœ¬
  3. æ›´æ–° search/info æŒ‡ä»¤æ”¯æ´è…³æœ¬æŸ¥è©¢
  4. èª¿æ•´ add æŒ‡ä»¤å¾ cache å®‰è£è…³æœ¬

  ---
  æ‚¨èªç‚ºé€™å€‹è©•ä¼°å¦‚ä½•ï¼Ÿè¦ç¹¼çºŒè¨­è¨ˆè©³ç´°çš„å¯¦ç¾æ–¹æ¡ˆå—ï¼Ÿ

> è«‹å¯¦ç¾æ–¹æ¡ˆ B-1ï¼ˆæ“´å±• ManifestCacheï¼‰ 

â— å¥½çš„ï¼æˆ‘ä¾†å¯¦ç¾æ–¹æ¡ˆ B-1ã€‚é€™æ˜¯ä¸€å€‹å¤šæ­¥é©Ÿçš„ä»»å‹™ï¼Œè®“æˆ‘å…ˆè¦åŠƒä¸€ä¸‹ï¼š

â— æ­¥é©Ÿ 1ï¼šå®šç¾© ScriptItem ä¸¦æ“´å±• SourceManifest

â— Update(src\core\manifest.rs)
  â¿ Â Updated src\core\manifest.rs with 31 additions                
       131        pub platforms: HashMap<String, PlatformBinary>,
       132    }
       133    
       134 +  /// Script item metadata (for bucket scripts)
       135 +  #[derive(Debug, Clone, Serialize, Deserialize)]
       136 +  pub struct ScriptItem {
       137 +      /// Script name (used as identifier)
       138 +      pub name: String,
       139 +  
       140 +      /// Short description
       141 +      pub description: String,
       142 +  
       143 +      /// Direct URL to the script file
       144 +      pub url: String,
       145 +  
       146 +      /// Script type
       147 +      pub script_type: ScriptType,
       148 +  
       149 +      /// Repository URL (for reference)
       150 +      pub repo: String,
       151 +  
       152 +      /// Optional SHA256 checksum
       153 +      #[serde(skip_serializing_if = "Option::is_none")]
       154 +      pub checksum: Option<String>,
       155 +  
       156 +      /// Homepage URL (optional)
       157 +      #[serde(skip_serializing_if = "Option::is_none")]
       158 +      pub homepage: Option<String>,
       159 +  
       160 +      /// License (optional)
       161 +      #[serde(skip_serializing_if = "Option::is_none")]
       162 +      pub license: Option<String>,
       163 +  }
       164 +  
       165    /// Source manifest (sources.json)
       166    #[derive(Debug, Clone, Serialize, Deserialize)]
       167    pub struct SourceManifest {

â— Update(src\core\manifest.rs)
  â¿ Â Updated src\core\manifest.rs with 14 additions                      
       167    pub struct SourceManifest {
       168        /// List of available packages
       169        pub packages: Vec<Package>,
       170 +  
       171 +      /// List of available scripts
       172 +      #[serde(default, skip_serializing_if = 
           + "Vec::is_empty")]
       173 +      pub scripts: Vec<ScriptItem>,
       174    }
       175    
       176    impl SourceManifest {
     ...
       174        pub fn new() -> Self {
       175            Self {
       176                packages: Vec::new(),
       177 +              scripts: Vec::new(),
       178            }
       179        }
       180    
     ...
       185                .filter(|p| p.platforms.contains_key(platform))
       186                .collect()
       187        }
       188 +  
       189 +      /// Get scripts that are supported on the current 
           + platform
       190 +      #[allow(dead_code)]
       191 +      pub fn scripts_for_current_platform(&self) -> 
           + Vec<&ScriptItem> {
       192 +          self.scripts
       193 +              .iter()
       194 +              .filter(|s| 
           + s.script_type.is_supported_on_current_platform())
       195 +              .collect()
       196 +      }
       197    }
       198    
       199    impl Default for SourceManifest {

â— Search(pattern: "SourceManifest.*\{", path: "src\core\manifest.rs",
        output_mode: "content")
  â¿ Â Found 20 lines (ctrl+o to expand)

â— æ­¥é©Ÿ 2ï¼šå®šç¾© CachedScript ä¸¦æ“´å±• ManifestCache

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 12 additions and 1 removal               
        4    //! This reduces GitHub API calls and improves performance.
        5    
        6    use crate::bucket::{Bucket, BucketConfig};
        7 -  use crate::core::manifest::{Package, PackageSource, 
          -  SourceManifest};
        7 +  use crate::core::manifest::{Package, PackageSource, 
          +  ScriptItem, SourceManifest};
        8    use anyhow::{Context, Result};
        9    use chrono::{DateTime, Utc};
       10    use serde::{Deserialize, Serialize};
     ...
       23        pub source: PackageSource,
       24    }
       25    
       26 +  /// Script with source information
       27 +  #[derive(Debug, Clone, Serialize, Deserialize)]
       28 +  pub struct CachedScript {
       29 +      /// The script data
       30 +      #[serde(flatten)]
       31 +      pub script: ScriptItem,
       32 +  
       33 +      /// Source origin
       34 +      pub source: PackageSource,
       35 +  }
       36 +  
       37    /// Source information in cache
       38    #[derive(Debug, Clone, Serialize, Deserialize)]
       39    pub struct CachedSourceInfo {

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 4 additions                    
       71    
       72        /// Cached packages (key: repo URL)
       73        pub packages: HashMap<String, CachedPackage>,
       74 +  
       75 +      /// Cached scripts (key: script name)
       76 +      #[serde(default, skip_serializing_if = 
          + "HashMap::is_empty")]
       77 +      pub scripts: HashMap<String, CachedScript>,
       78    }
       79    
       80    fn default_ttl() -> i64 {

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 1 addition           
       90                ttl_seconds: default_ttl(),
       91                sources: HashMap::new(),
       92                packages: HashMap::new(),
       93 +              scripts: HashMap::new(),
       94            }
       95        }
       96    

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 16 additions                              
       135                .insert(repo, CachedPackage { package, source 
             });
       136        }
       137    
       138 +      /// Add a script to cache
       139 +      pub fn add_script(&mut self, script: ScriptItem, 
           + source: PackageSource) {
       140 +          let name = script.name.clone();
       141 +          self.scripts
       142 +              .insert(name, CachedScript { script, source });
       143 +      }
       144 +  
       145        /// Get all packages as Vec (for compatibility with 
             SourceManifest)
       146        pub fn get_packages(&self) -> Vec<Package> {
       147            self.packages
     ...
       143                .collect()
       144        }
       145    
       146 +      /// Get all scripts as Vec
       147 +      pub fn get_scripts(&self) -> Vec<ScriptItem> {
       148 +          self.scripts
       149 +              .values()
       150 +              .map(|cs| cs.script.clone())
       151 +              .collect()
       152 +      }
       153 +  
       154        /// Convert cache to SourceManifest for compatibility
       155        pub fn to_source_manifest(&self) -> SourceManifest {
       156            SourceManifest {
       157                packages: self.get_packages(),
       158 +              scripts: self.get_scripts(),
       159            }
       160        }
       161    

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 15 additions                              
       172            self.packages.values().find(|cp| cp.package.name ==
              name)
       173        }
       174    
       175 +      /// Find a script by name
       176 +      #[allow(dead_code)]
       177 +      pub fn find_script(&self, name: &str) -> 
           + Option<&CachedScript> {
       178 +          self.scripts.get(name)
       179 +      }
       180 +  
       181        /// Get packages filtered by source
       182        #[allow(dead_code)]
       183        pub fn packages_by_source(&self, source_type: 
             &PackageSource) -> Vec<&CachedPackage> {
     ...
       180                .filter(|cp| &cp.source == source_type)
       181                .collect()
       182        }
       183 +  
       184 +      /// Get scripts filtered by source
       185 +      #[allow(dead_code)]
       186 +      pub fn scripts_by_source(&self, source_type: 
           + &PackageSource) -> Vec<&CachedScript> {
       187 +          self.scripts
       188 +              .values()
       189 +              .filter(|cs| &cs.source == source_type)
       190 +              .collect()
       191 +      }
       192    }
       193    
       194    impl Default for ManifestCache {

â— æ­¥é©Ÿ 3ï¼šæ›´æ–° build_cache() è™•ç†è…³æœ¬

â— Update(src\cache.rs)
  â¿ Â Updated src\cache.rs with 13 additions and 1 removal               
       221            match fetch_bucket_fn(bucket) {
       222                Ok(manifest) => {
       223                    let package_count = 
             manifest.packages.len();
       224 +                  let script_count = manifest.scripts.len();
       225 +                  let total_count = package_count + 
           + script_count;
       226    
       227                    // Add packages
       228                    for package in manifest.packages {
     ...
       232                        );
       233                    }
       234    
       235 +                  // Add scripts
       236 +                  for script in manifest.scripts {
       237 +                      cache.add_script(
       238 +                          script,
       239 +                          PackageSource::Bucket {
       240 +                              name: bucket.name.clone(),
       241 +                          },
       242 +                      );
       243 +                  }
       244 +  
       245                    // Record source info
       246                    cache.sources.insert(
       247                        source_key,
     ...
       239                            source: PackageSource::Bucket {
       240                                name: bucket.name.clone(),
       241                            },
       242 -                          package_count,
       242 +                          package_count: total_count,
       243                            last_fetched: Some(now),
       244                            url: Some(bucket.url.clone()),
       245                        },

â— Bash(cargo check)
  â¿     Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)       
        Finished `dev` profile [unoptimized + debuginfo] target(s) in 13.32
    s


â— æ­¥é©Ÿ 4ï¼šæ›´æ–° search æŒ‡ä»¤æ”¯æ´è…³æœ¬æœç´¢

â— Read(src\commands\search.rs)
  â¿ Â Read 105 lines

â— Update(src\commands\search.rs)
  â¿ Â Updated src\commands\search.rs with 85 additions and 32 removals    
        5    use colored::Colorize;
        6    use glob::Pattern;
        7    
        8 -  /// Search for packages
        8 +  /// Search for packages and scripts
        9    pub fn run(patterns: Vec<String>) -> Result<()> {
       10        let config = Config::new()?;
       11    
       12 -      // Load manifest from cache (includes local + bucket 
          - sources)
       13 -      let manifest = config.get_packages_from_cache()?;
       12 +      // Load cache
       13 +      let cache = config.get_or_rebuild_cache()?;
       14    
       15 -      if manifest.packages.is_empty() {
       16 -          println!("{}", "No packages in sources".yellow());
       17 -          println!("Add packages with: wenpm source add <
          -  github-url>");
       15 +      if cache.packages.is_empty() && cache.scripts.is_empty()
          +  {
       16 +          println!("{}", "No packages or scripts 
          +  in sources".yellow());
       17 +          println!("Add buckets with: wenget bucket add <
          +  name> <url>");
       18            return Ok(());
       19        }
       20    
       21        if patterns.is_empty() {
       22            println!("{}", "No search pattern 
            provided".yellow());
       23 -          println!("Usage: wenpm search <name>...");
       23 +          println!("Usage: wenget search <name>...");
       24            return Ok(());
       25        }
       26    
     ...
       35            .collect::<Result<_, _>>()?;
       36    
       37        // Filter packages
       38 -      let matching_packages: Vec<_> = manifest
       38 +      let matching_packages: Vec<_> = cache
       39            .packages
       40 -          .iter()
       41 -          .filter(|pkg| {
       40 +          .values()
       41 +          .filter(|cached_pkg| {
       42 +              let pkg = &cached_pkg.package;
       43                // Check if name matches any pattern
       44                let name_matches = glob_patterns
       45                    .iter()
     ...
       51            })
       52            .collect();
       53    
       54 -      if matching_packages.is_empty() {
       54 +      // Filter scripts
       55 +      let matching_scripts: Vec<_> = cache
       56 +          .scripts
       57 +          .values()
       58 +          .filter(|cached_script| {
       59 +              let script = &cached_script.script;
       60 +              // Check if name matches any pattern
       61 +              let name_matches = glob_patterns
       62 +                  .iter()
       63 +                  .any(|pattern| 
          + pattern.matches(&script.name));
       64 +  
       65 +              // Check if supports current platform
       66 +              let platform_matches = 
          + script.script_type.is_supported_on_current_platform();
       67 +  
       68 +              name_matches && platform_matches
       69 +          })
       70 +          .collect();
       71 +  
       72 +      if matching_packages.is_empty() && 
          + matching_scripts.is_empty() {
       73            println!(
       74                "{}",
       75 -              format!("No packages 
          -  found matching: {:?}", patterns).yellow()
       75 +              format!("No packages or scripts 
          +  found matching: {:?}", patterns).yellow()
       76            );
       77            return Ok(());
       78        }
     ...
        62        // Print header
        63        println!("{}", format!("Search results for: {:?}", 
             patterns).bold());
        64        println!();
        65 -      println!(
        66 -          "{:<20} {:<10} {}",
        67 -          "NAME".bold(),
        68 -          "SIZE".bold(),
        69 -          "DESCRIPTION".bold()
        70 -      );
        71 -      println!("{}", "â”€".repeat(80));
        65    
        66        // Print packages
        67 -      for pkg in &matching_packages {
        68 -          // Find the first matching platform
        69 -          let platform_binary = platform_ids
        70 -              .iter()
        71 -              .find_map(|id| pkg.platforms.get(id))
        72 -              .unwrap();
        67 +      if !matching_packages.is_empty() {
        68 +          println!("{}", "Binary Packages:".bold().cyan());
        69 +          println!(
        70 +              "{:<20} {:<10} {}",
        71 +              "NAME".bold(),
        72 +              "SIZE".bold(),
        73 +              "DESCRIPTION".bold()
        74 +          );
        75 +          println!("{}", "â”€".repeat(80));
        76    
        77 -          let size_mb = platform_binary.size as f64 / 
           - 1_000_000.0;
        77 +          for cached_pkg in &matching_packages {
        78 +              let pkg = &cached_pkg.package;
        79 +              // Find the first matching platform
        80 +              let platform_binary = platform_ids
        81 +                  .iter()
        82 +                  .find_map(|id| pkg.platforms.get(id))
        83 +                  .unwrap();
        84    
        85 +              let size_mb = platform_binary.size as f64 / 
           + 1_000_000.0;
        86 +  
        87 +              println!(
        88 +                  "{:<20} {:>8.1} MB  {}",
        89 +                  pkg.name.green(),
        90 +                  size_mb,
        91 +                  truncate(&pkg.description, 50)
        92 +              );
        93 +          }
        94 +          println!();
        95 +      }
        96 +  
        97 +      // Print scripts
        98 +      if !matching_scripts.is_empty() {
        99 +          println!("{}", "Scripts:".bold().cyan());
       100            println!(
       101 -              "{:<20} {:>8.1} MB  {}",
       102 -              pkg.name.green(),
       103 -              size_mb,
       104 -              truncate(&pkg.description, 50)
       101 +              "{:<20} {:<10} {}",
       102 +              "NAME".bold(),
       103 +              "TYPE".bold(),
       104 +              "DESCRIPTION".bold()
       105            );
       106 +          println!("{}", "â”€".repeat(80));
       107 +  
       108 +          for cached_script in &matching_scripts {
       109 +              let script = &cached_script.script;
       110 +              let script_type = 
           + script.script_type.display_name();
       111 +  
       112 +              println!(
       113 +                  "{:<20} {:<10} {}",
       114 +                  script.name.green(),
       115 +                  script_type.yellow(),
       116 +                  truncate(&script.description, 50)
       117 +              );
       118 +          }
       119 +          println!();
       120        }
       121    
       122 -      println!();
       123 -      println!("Found: {} package(s)", 
           - matching_packages.len());
       122 +      println!(
       123 +          "Found: {} package(s), {} script(s)",
       124 +          matching_packages.len(),
       125 +          matching_scripts.len()
       126 +      );
       127    
       128        Ok(())
       129    }

â— æ­¥é©Ÿ 5ï¼šæ›´æ–° info æŒ‡ä»¤é¡¯ç¤ºè…³æœ¬ä¿¡æ¯

â— Read(src\commands\info.rs)
  â¿ Â Read 148 lines

â— Update(src\commands\info.rs)
  â¿ Â Updated src\commands\info.rs with 20 additions and 5 removals       
        7    use anyhow::Result;
        8    use colored::Colorize;
        9    
       10 -  /// Show package information
       10 +  /// Show package and script information
       11    pub fn run(names: Vec<String>) -> Result<()> {
       12        let config = Config::new()?;
       13        let resolver = PackageResolver::new(Config::new()?)?;
     ...
       26        // Load installed packages for status checking
       27        let installed = config.get_or_create_installed()?;
       28    
       29 +      // Load cache for script lookup
       30 +      let cache = config.get_or_rebuild_cache()?;
       31 +  
       32        let mut total_found = 0;
       33    
       34        for name in &names {
       35            let input = PackageInput::parse(name);
       36    
       37 +          // First try to resolve as package
       38            match resolver.resolve(&input) {
       39                Ok(packages) => {
       40                    for resolved in packages {
     ...
       43                        total_found += 1;
       44                    }
       45                }
       46 -              Err(e) => {
       47 -                  eprintln!("{} {}: {}", "Error".red().bold(),
          -  name, e);
       46 +              Err(_) => {
       47 +                  // If not found as package, try as script
       48 +                  if let Some(cached_script) = 
          + cache.find_script(name) {
       49 +                      if total_found > 0 {
       50 +                          println!();
       51 +                          println!("{}", "â”€".repeat(80));
       52 +                          println!();
       53 +                      }
       54 +                      display_script_info(cached_script, 
          + &installed)?;
       55 +                      total_found += 1;
       56 +                  } else {
       57 +                      eprintln!("{} {}: Not found", 
          + "Error".red().bold(), name);
       58 +                  }
       59                }
       60            }
       61        }
       62    
       63        if total_found == 0 {
       64 -          println!("{}", "No packages found".yellow());
       64 +          println!("{}", "No packages or scripts 
          +  found".yellow());
       65        } else if total_found > 1 {
       66            println!();
       67            println!(
       68                "{}",
       69 -              format!("Found {} package
          -  (s)", total_found).green().bold()
       69 +              format!("Found {} item
          +  (s)", total_found).green().bold()
       70            );
       71        }
       72    

â— Update(src\commands\info.rs)
  â¿ Â Error editing file

â— Update(src\commands\info.rs)
  â¿ Â Updated src\commands\info.rs with 71 additions                      
       160    
       161        Ok(())
       162    }
       163 +  
       164 +  /// Display detailed information for a single script
       165 +  fn display_script_info(
       166 +      cached_script: &crate::cache::CachedScript,
       167 +      installed: &crate::core::InstalledManifest,
       168 +  ) -> Result<()> {
       169 +      let script = &cached_script.script;
       170 +  
       171 +      // Header
       172 +      println!("{} {}", script.name.bold().cyan(), 
           + "[Script]".magenta());
       173 +      println!("{}", "â”€".repeat(60));
       174 +  
       175 +      // Basic info
       176 +      println!("{:<16} {}", "Script type:".bold(), 
           + script.script_type.display_name());
       177 +      println!("{:<16} {}", "URL:".bold(), script.url);
       178 +      println!("{:<16} {}", "Repository:".bold(), 
           + script.repo);
       179 +  
       180 +      if let Some(ref homepage) = script.homepage {
       181 +          println!("{:<16} {}", "Homepage:".bold(), 
           + homepage);
       182 +      }
       183 +  
       184 +      if let Some(ref license) = script.license {
       185 +          println!("{:<16} {}", "License:".bold(), license);
       186 +      }
       187 +  
       188 +      println!("{:<16} {}", "Description:".bold(), 
           + script.description);
       189 +  
       190 +      // Source
       191 +      match &cached_script.source {
       192 +          crate::core::manifest::PackageSource::Bucket { name
           +  } => {
       193 +              println!("{:<16} {} ({})", "Source:".bold(), 
           + "Bucket".green(), name);
       194 +          }
       195 +          crate::core::manifest::PackageSource::DirectRepo { 
           + url: _ } => {
       196 +              println!("{:<16} {}", "Source:".bold(), "Direct
           +  URL".yellow());
       197 +          }
       198 +          crate::core::manifest::PackageSource::Script { 
           + origin, script_type } => {
       199 +              println!(
       200 +                  "{:<16} {} ({} from {})",
       201 +                  "Source:".bold(),
       202 +                  "Script".magenta(),
       203 +                  script_type.display_name(),
       204 +                  origin
       205 +              );
       206 +          }
       207 +      }
       208 +  
       209 +      // Installation status
       210 +      if let Some(inst_pkg) = 
           + installed.get_package(&script.name) {
       211 +          println!(
       212 +              "{:<16} {}",
       213 +              "Status:".bold(),
       214 +              "Installed".green()
       215 +          );
       216 +          println!("{:<16} {}", "Command name:".bold(), 
           + inst_pkg.command_name.yellow());
       217 +          println!("{:<16} {}", "Installed at:".bold(), 
           + inst_pkg.installed_at);
       218 +          println!("{:<16} {}", "Install path:".bold(), 
           + inst_pkg.install_path);
       219 +      } else {
       220 +          println!("{:<16} {}", "Status:".bold(), "Not 
           + installed".yellow());
       221 +      }
       222 +  
       223 +      // Platform support
       224 +      println!();
       225 +      let platform_supported = 
           + script.script_type.is_supported_on_current_platform();
       226 +      if platform_supported {
       227 +          println!("{} {}", "Current platform:".bold(), 
           + "Supported".green());
       228 +      } else {
       229 +          println!("{} {}", "Current platform:".bold(), "Not 
           + supported".red());
       230 +      }
       231 +  
       232 +      Ok(())
       233 +  }

â— æœ€çµ‚æ¸¬è©¦

â— Bash(cargo check)
  â¿     Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)       
        Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.23s


â— Bash(cargo build --release) timeout: 3m 0s
  â¿ Â    Compiling wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)
         Finished `release` profile [optimized] target(s) in 52.68s

â— âœ… æ–¹æ¡ˆ B-1 å¯¦ç¾å®Œæˆï¼

  ğŸ“ å¯¦ç¾ç¸½çµ

  å·²æˆåŠŸå¯¦ç¾ æ–¹æ¡ˆ B-1ï¼ˆæ“´å±• ManifestCacheï¼‰ï¼Œè®“ bucket
  æ ¼å¼å¯ä»¥ç›¸å®¹ç·šä¸Šè…³æœ¬ã€‚

  ---
  ğŸ¯ å·²å®Œæˆçš„ä¿®æ”¹

  1. æ ¸å¿ƒçµæ§‹æ“´å±• (src/core/manifest.rs)

  æ–°å¢ ScriptItem çµæ§‹ï¼š (135-163 è¡Œ)
  pub struct ScriptItem {
      pub name: String,
      pub description: String,
      pub url: String,              // ç›´æ¥ä¸‹è¼‰ URL
      pub script_type: ScriptType,  // PowerShell/Batch/Bash/Python
      pub repo: String,
      pub checksum: Option<String>,
      pub homepage: Option<String>,
      pub license: Option<String>,
  }

  æ“´å±• SourceManifestï¼š (167-174 è¡Œ)
  pub struct SourceManifest {
      pub packages: Vec<Package>,
      pub scripts: Vec<ScriptItem>,  // âœ… æ–°å¢
  }

  2. Cache ç³»çµ±æ“´å±• (src/cache.rs)

  æ–°å¢ CachedScript çµæ§‹ï¼š (27-35 è¡Œ)
  pub struct CachedScript {
      #[serde(flatten)]
      pub script: ScriptItem,
      pub source: PackageSource,
  }

  æ“´å±• ManifestCacheï¼š (75-77 è¡Œ)
  pub struct ManifestCache {
      pub packages: HashMap<String, CachedPackage>,
      pub scripts: HashMap<String, CachedScript>,  // âœ… æ–°å¢
      ...
  }

  æ–°å¢æ–¹æ³•ï¼š
  - add_script() - æ·»åŠ è…³æœ¬åˆ° cache (139-143 è¡Œ)
  - get_scripts() - ç²å–æ‰€æœ‰è…³æœ¬ (154-159 è¡Œ)
  - find_script() - æŒ‰åç¨±æŸ¥æ‰¾è…³æœ¬ (176-179 è¡Œ)
  - scripts_by_source() - æŒ‰ä¾†æºéæ¿¾è…³æœ¬ (191-197 è¡Œ)

  3. Cache æ§‹å»ºé‚è¼¯ (src/cache.rs:207-268)

  æ›´æ–° build_cache()ï¼š
  - è™•ç† manifest.scripts
  - çµ±è¨ˆè…³æœ¬æ•¸é‡
  - å°‡è…³æœ¬æ·»åŠ åˆ° cache

  4. Search æŒ‡ä»¤æ›´æ–° (src/commands/search.rs)

  æ”¯æ´è…³æœ¬æœç´¢ï¼š
  - åŒæ™‚æœç´¢ packages å’Œ scripts
  - åˆ†åˆ¥é¡¯ç¤ºäºŒé€²åˆ¶åŒ…å’Œè…³æœ¬
  - é¡¯ç¤ºè…³æœ¬é¡å‹ï¼ˆPowerShell/Bash ç­‰ï¼‰

  è¼¸å‡ºæ ¼å¼ï¼š
  Binary Packages:
  NAME                 SIZE       DESCRIPTION
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Scripts:
  NAME                 TYPE       DESCRIPTION
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  5. Info æŒ‡ä»¤æ›´æ–° (src/commands/info.rs)

  æ”¯æ´è…³æœ¬ä¿¡æ¯æŸ¥è©¢ï¼š
  - å„ªå…ˆæŸ¥æ‰¾ packageï¼Œæ‰¾ä¸åˆ°å‰‡æŸ¥æ‰¾ script
  - é¡¯ç¤ºè…³æœ¬è©³ç´°ä¿¡æ¯ï¼ˆé¡å‹ã€URLã€å¹³å°æ”¯æ´ç­‰ï¼‰
  - é¡¯ç¤ºå®‰è£ç‹€æ…‹

  ---
  âœ… å‘å¾Œç›¸å®¹æ€§

  å®Œå…¨ç›¸å®¹ï¼š
  - âœ… èˆŠçš„ manifest.jsonï¼ˆæ²’æœ‰ scripts æ¬„ä½ï¼‰å¯ä»¥æ­£å¸¸è®€å–
  - âœ… èˆŠçš„ manifest-cache.json å¯ä»¥æ­£å¸¸åŠ è¼‰
  - âœ… installed.json å·²ç¶“æ”¯æ´ Script é¡å‹ï¼Œç„¡éœ€ä¿®æ”¹
  - âœ… ç¾æœ‰çš„ bucket ä¸å—å½±éŸ¿

  ---
  ğŸ“Š Bucket Manifest ç¯„ä¾‹

  æ–°çš„ manifest.json æ ¼å¼ï¼š
  {
    "packages": [
      {
        "name": "ripgrep",
        "description": "Line-oriented search tool",
        "repo": "https://github.com/BurntSushi/ripgrep",
        "platforms": { ... }
      }
    ],
    "scripts": [
      {
        "name": "my-script",
        "description": "Useful PowerShell script",
        "url":
  "https://raw.githubusercontent.com/user/repo/main/script.ps1",
        "script_type": "powershell",
        "repo": "https://github.com/user/repo",
        "checksum": "sha256:..."
      }
    ]
  }

  ---
  ğŸ‰ æ¸¬è©¦çµæœ

  - âœ… cargo check - é€šé
  - âœ… cargo build --release - é€šé
  - âœ… æ‰€æœ‰çµæ§‹å‘å¾Œç›¸å®¹

  ---
  ğŸ“ ä¸‹ä¸€æ­¥å»ºè­°

  ç¾åœ¨å¯ä»¥ï¼š
  1. å‰µå»ºæ¸¬è©¦ bucket - åŒ…å«è…³æœ¬çš„ manifest.json
  2. æ›´æ–° add æŒ‡ä»¤ - æ”¯æ´å¾ bucket å®‰è£è…³æœ¬
  3. æ¸¬è©¦å®Œæ•´æµç¨‹ - bucket add â†’ search â†’ info â†’ add

  éœ€è¦æˆ‘ç¹¼çºŒå¯¦ç¾ add æŒ‡ä»¤æ”¯æ´å¾ bucket å®‰è£è…³æœ¬å—ï¼Ÿ

> ç¹¼çºŒå¯¦ç¾ add æŒ‡ä»¤æ”¯æ´å¾ bucket å®‰è£è…³æœ¬ 

â— å¥½çš„ï¼æˆ‘ä¾†å¯¦ç¾ add æŒ‡ä»¤æ”¯æ´å¾ bucket å®‰è£è…³æœ¬ã€‚è®“æˆ‘å…ˆåˆ†æä¸€ä¸‹éœ€è¦åšä»€éº¼ï¼š

â— Read(src\commands\add.rs)
  â¿ Â Read 80 lines

â— Read(src\commands\add.rs)
  â¿ Â Read 50 lines

â— ä¿®æ”¹ install_packages å‡½æ•¸

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 36 additions and 3 removals        
       263        let platform = Platform::current();
       264        let platform_ids = platform.possible_identifiers();
       265    
       266 -      // Resolve all inputs and collect packages to install
       266 +      // Load cache for script lookup
       267 +      let cache = config.get_or_rebuild_cache()?;
       268 +  
       269 +      // Resolve all inputs and collect packages/scripts to 
           + install
       270        let resolver = PackageResolver::new(Config::new()?)?;
       271        let mut packages_to_install: Vec<ResolvedPackage> = 
             Vec::new();
       272 +      let mut scripts_to_install: Vec<(String, String, 
           + ScriptType, String)> = Vec::new(); // (name, url, type, 
           + origin)
       273    
       274        for name in &names {
       275            let input = PackageInput::parse(name);
     ...
       290                        packages_to_install.push(pkg_resolved);
       291                    }
       292                }
       293 -              Err(e) => {
       294 -                  eprintln!("{} {}: {}", 
           - "Error".red().bold(), name, e);
       293 +              Err(_) => {
       294 +                  // If not found as package, check if it's a
           +  script in cache
       295 +                  if let Some(cached_script) = 
           + cache.find_script(name) {
       296 +                      let script = &cached_script.script;
       297 +  
       298 +                      // Check platform support
       299 +                      if 
           + !script.script_type.is_supported_on_current_platform() {
       300 +                          println!(
       301 +                              "{} {} ({}) is not supported on
           +  current platform",
       302 +                              "Warning:".yellow(),
       303 +                              script.name,
       304 +                              
           + script.script_type.display_name()
       305 +                          );
       306 +                          continue;
       307 +                      }
       308 +  
       309 +                      // Prepare script for installation
       310 +                      let source_name = match 
           + &cached_script.source {
       311 +                          PackageSource::Bucket { name } => 
           + format!("bucket:{}", name),
       312 +                          _ => "unknown".to_string(),
       313 +                      };
       314 +  
       315 +                      scripts_to_install.push((
       316 +                          script.name.clone(),
       317 +                          script.url.clone(),
       318 +                          script.script_type.clone(),
       319 +                          source_name,
       320 +                      ));
       321 +                  } else {
       322 +                      eprintln!("{} {}: Not found", 
           + "Error".red().bold(), name);
       323 +                  }
       324                }
       325            }
       326        }

â— Read(src\commands\add.rs)
  â¿ Â Read 120 lines

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 11 additions and 5 removals       
       329            }
       330        }
       331    
       332 -      if packages_to_install.is_empty() {
       333 -          println!("{}", "No packages to install".yellow());
       332 +      if packages_to_install.is_empty() 
           +  && scripts_to_install.is_empty() {
       333 +          println!("{}", "No packages or scripts 
           +  to install".yellow());
       334            return Ok(());
       335        }
       336    
       337 -      // Create GitHub provider to fetch versions
       338 -      let github = GitHubProvider::new()?;
       337 +      // Create GitHub provider to fetch versions
           +   (for packages)
       338 +      let github = if !packages_to_install.is_empty() {
       339 +          Some(GitHubProvider::new()?)
       340 +      } else {
       341 +          None
       342 +      };
       343    
       344        // Show packages to install with versions and handle 
             already-installed packages
       345 -      println!("{}", "Packages to install:".bold());
       345 +      if !packages_to_install.is_empty() {
       346 +          println!("{}", "Packages to install:".bold());
       347 +      }
       348    
       349        let mut to_install: Vec<ResolvedPackage> = Vec::new();
       350        let mut to_update: Vec<ResolvedPackage> = Vec::new();

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 6 additions and 3 removals        
       354            let repo = &resolved.package.repo;
       355    
       356            // Fetch latest version
       357 -          let version = github
       358 -              .fetch_latest_version(repo)
       359 -              .unwrap_or_else(|_| "unknown".to_string());
       357 +          let version = if let Some(ref gh) = github {
       358 +              gh.fetch_latest_version(repo)
       359 +                  .unwrap_or_else(|_| "unknown".to_string())
       360 +          } else {
       361 +              "unknown".to_string()
       362 +          };
       363    
       364            if installed.is_installed(pkg_name) {
       365                // Package already installed

â— Read(src\commands\add.rs)
  â¿ Â Read 30 lines

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 31 additions and 2 removals   
       396            }
       397        }
       398    
       399 +      // Show scripts to install
       400 +      let mut scripts_to_process: Vec<(String, String, 
           + ScriptType, String)> = Vec::new();
       401 +  
       402 +      if !scripts_to_install.is_empty() {
       403 +          println!();
       404 +          println!("{}", "Scripts to install:".bold());
       405 +  
       406 +          for (name, url, script_type, origin) in 
           + scripts_to_install {
       407 +              if installed.is_installed(&name) {
       408 +                  println!(
       409 +                      "  {} {} ({}) {}",
       410 +                      "â€¢".yellow(),
       411 +                      name,
       412 +                      script_type.display_name(),
       413 +                      "(already installed, will 
           + update)".dimmed()
       414 +                  );
       415 +              } else {
       416 +                  println!(
       417 +                      "  {} {} ({}) {}",
       418 +                      "â€¢".green(),
       419 +                      name,
       420 +                      script_type.display_name(),
       421 +                      "(new)".green()
       422 +                  );
       423 +              }
       424 +              scripts_to_process.push((name, url, 
           + script_type, origin));
       425 +          }
       426 +      }
       427 +  
       428        // Check if there's anything to do
       429 -      if to_install.is_empty() && to_update.is_empty() {
       429 +      if to_install.is_empty() && to_update.is_empty() 
           +  && scripts_to_process.is_empty() {
       430            println!();
       431 -          println!("{}", "All packages 
           -  are already up to date".green());
       431 +          println!("{}", "All packages and scripts 
           +  are already up to date".green());
       432            return Ok(());
       433        }
       434    

â— Read(src\commands\add.rs)
  â¿ Â Read 50 lines

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 35 additions                     
       543            }
       544        }
       545    
       546 +      // Install scripts from bucket cache
       547 +      let mut script_success_count = 0;
       548 +      let mut script_fail_count = 0;
       549 +  
       550 +      for (name, url, script_type, origin) in 
           + scripts_to_process {
       551 +          println!("{}", format!("Installing {} ({})...", 
           + name, script_type.display_name()).bold());
       552 +  
       553 +          match install_script_from_bucket(
       554 +              config,
       555 +              paths,
       556 +              &mut installed,
       557 +              &name,
       558 +              &url,
       559 +              script_type.clone(),
       560 +              &origin,
       561 +              custom_name,
       562 +          ) {
       563 +              Ok(_) => {
       564 +                  println!("  {} Installed successfully", 
           + "âœ“".green());
       565 +                  script_success_count += 1;
       566 +              }
       567 +              Err(e) => {
       568 +                  println!("  {} {}", "âœ—".red(), e);
       569 +                  script_fail_count += 1;
       570 +              }
       571 +          }
       572 +          println!();
       573 +      }
       574 +  
       575        // Summary
       576        println!("{}", "Summary:".bold());
       577        if success_count > 0 {
     ...
       551        if fail_count > 0 {
       552            println!("  {} {} package(s) failed", "âœ—".red(), 
             fail_count);
       553        }
       554 +      if script_success_count > 0 {
       555 +          println!("  {} {} script(s) installed", 
           + "âœ“".green(), script_success_count);
       556 +      }
       557 +      if script_fail_count > 0 {
       558 +          println!("  {} {} script(s) failed", "âœ—".red(), 
           + script_fail_count);
       559 +      }
       560    
       561        Ok(())
       562    }

â— Bash(wc -l src/commands/add.rs)
  â¿ Â 764 src/commands/add.rs

â— Read(src\commands\add.rs)
  â¿ Â Read 16 lines

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 50 additions                       
       762    
       763        Ok(count)
       764    }
       765 +  
       766 +  /// Install a script from bucket cache
       767 +  fn install_script_from_bucket(
       768 +      config: &Config,
       769 +      paths: &WenPaths,
       770 +      installed: &mut crate::core::InstalledManifest,
       771 +      name: &str,
       772 +      url: &str,
       773 +      script_type: ScriptType,
       774 +      origin: &str,
       775 +      custom_name: Option<&str>,
       776 +  ) -> Result<()> {
       777 +      println!("  Downloading script from {}...", url);
       778 +  
       779 +      // Download script content
       780 +      let content = download_script(url)?;
       781 +  
       782 +      // Determine the final command name
       783 +      let command_name = custom_name.unwrap_or(name);
       784 +  
       785 +      println!("  Installing script as '{}'...", 
           + command_name);
       786 +  
       787 +      // Install script to app directory
       788 +      let files = install_script(paths, command_name, 
           + &content, &script_type)?;
       789 +  
       790 +      // Create shim
       791 +      println!("  Creating launcher...");
       792 +      create_script_shim(paths, command_name, &script_type)?;
       793 +  
       794 +      // Create installed package info
       795 +      let inst_pkg = InstalledPackage {
       796 +          version: "script".to_string(),
       797 +          platform: std::env::consts::OS.to_string(),
       798 +          installed_at: Utc::now(),
       799 +          install_path: 
           + paths.app_dir(command_name).display().to_string(),
       800 +          files,
       801 +          source: PackageSource::Script {
       802 +              origin: origin.to_string(),
       803 +              script_type: script_type.clone(),
       804 +          },
       805 +          description: format!("{} script from bucket", 
           + script_type.display_name()),
       806 +          command_name: command_name.to_string(),
       807 +      };
       808 +  
       809 +      // Update installed manifest
       810 +      installed.upsert_package(name.to_string(), inst_pkg);
       811 +      config.save_installed(installed)?;
       812 +  
       813 +      Ok(())
       814 +  }

â— Bash(cargo check)
  â¿ Â Error: Exit code 101
         Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)
     error[E0599]: no method named `fetch_package` found for enum 
     `std::option::Option` in the current scope
        --> src\commands\add.rs:469:70
         |
     469 |         let (pkg_to_install, version, using_fallback) = match 
     github.fetch_package(repo_url) {
         |                                                                      
     ^^^^^^^^^^^^^ method not found in `std::option::Option<GitHubProvider>`
         |
     note: the method `fetch_package` exists on the type `GitHubProvider`
        --> src\providers\base.rs:15:5
     â€¦ +68 lines (ctrl+o to see all)

â— Read(src\commands\add.rs)
  â¿ Â Read 40 lines

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 28 additions and 23 removals       
       466    
       467            // Try to fetch latest package info from GitHub API
              (includes latest download links)
       468            // If API rate limit is hit, fallback to cached 
             package info
       469 -          let (pkg_to_install, version, using_fallback) = 
           -  match github.fetch_package(repo_url) {
       470 -              Ok(latest_pkg) => {
       471 -                  // Successfully fetched from GitHub API - 
           - use latest download links
       472 -                  let version = github
       473 -                      .fetch_latest_version(repo_url)
       474 -                      .unwrap_or_else(|_| 
           - "unknown".to_string());
       475 -                  (latest_pkg, version, false)
       476 -              }
       477 -              Err(e) => {
       478 -                  // Failed to fetch from GitHub API (likely 
           - rate limit) - use cached package info
       479 -                  log::warn!(
       480 -                      "Failed to fetch latest package info 
           - from GitHub API for {}: {}",
       481 -                      pkg_name,
       482 -                      e
       483 -                  );
       484 -                  println!(
       485 -                      "  {} Using cached download links 
           - (GitHub API unavailable)",
       486 -                      "âš ".yellow()
       487 -                  );
       469 +          let (pkg_to_install, version, using_fallback) = if 
           +  let Some(ref gh) = github {
       470 +              match gh.fetch_package(repo_url) {
       471 +                  Ok(latest_pkg) => {
       472 +                      // Successfully fetched from GitHub API
           +  - use latest download links
       473 +                      let version = gh
       474 +                          .fetch_latest_version(repo_url)
       475 +                          .unwrap_or_else(|_| 
           + "unknown".to_string());
       476 +                      (latest_pkg, version, false)
       477 +                  }
       478 +                  Err(e) => {
       479 +                      // Failed to fetch from GitHub API 
           + (likely rate limit) - use cached package info
       480 +                      log::warn!(
       481 +                          "Failed to fetch latest package 
           + info from GitHub API for {}: {}",
       482 +                          pkg_name,
       483 +                          e
       484 +                      );
       485 +                      println!(
       486 +                          "  {} Using cached download links 
           + (GitHub API unavailable)",
       487 +                          "âš ".yellow()
       488 +                      );
       489    
       490 -                  let version = github
       491 -                      .fetch_latest_version(repo_url)
       492 -                      
           -  .unwrap_or_else(|_| "unknown".to_string());
       493 -                  (resolved.package.clone(), version, true)
       490 +                      let version = gh
       491 +                          .fetch_latest_version(repo_url)
       492 +                          
           +  .unwrap_or_else(|_| "unknown".to_string());
       493 +                      
           +  (resolved.package.clone(), version, true)
       494 +                  }
       495                }
       496 +          } else {
       497 +              // No GitHub provider available, use cached 
           + package info
       498 +              (resolved.package.clone(), 
           + "unknown".to_string(), true)
       499            };
       500    
       501            println!("{} {} v{}...", "Installing".cyan(), 
             pkg_name, version);

â— Bash(cargo check)
  â¿ Â Error: Exit code 101
         Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)
     error[E0596]: cannot borrow `installed` as mutable, as it is not declared as
      mutable
        --> src\commands\add.rs:561:13
         |
     561 |             &mut installed,
         |             ^^^^^^^^^^^^^^ cannot borrow as mutable
         |
     note: the binding is already a mutable borrow
        --> src\commands\add.rs:256:16
     â€¦ +11 lines (ctrl+o to see all)

â— Update(src\commands\add.rs)
  â¿ Â Updated src\commands\add.rs with 1 addition and 1 removal
       558            match install_script_from_bucket(
       559                config,
       560                paths,
       561 -              &mut installed,
       561 +              installed,
       562                &name,
       563                &url,
       564                script_type.clone(),

â— Bash(cargo check)
  â¿     Checking wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)       
        Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.25s


â— Bash(cargo build --release) timeout: 3m 0s
  â¿ Â    Compiling wenget v0.4.0 (D:\Users\user\Documents\rust\wenget)
         Finished `release` profile [optimized] target(s) in 52.17s

â— âœ… add æŒ‡ä»¤æ”¯æ´å¾ bucket å®‰è£è…³æœ¬ - å¯¦ç¾å®Œæˆï¼

  ğŸ¯ å¯¦ç¾ç¸½çµ

  å·²æˆåŠŸå¯¦ç¾ add æŒ‡ä»¤æ”¯æ´å¾ bucket cache å®‰è£è…³æœ¬ï¼ç¾åœ¨ç”¨æˆ¶å¯ä»¥é€šé wenget 
  add <script-name> å¾ bucket å®‰è£è…³æœ¬ã€‚

  ---
  ğŸ“ å¯¦ç¾çš„åŠŸèƒ½

  1. æ™ºæ…§è­˜åˆ¥è…³æœ¬ (src/commands/add.rs:297-330)

  ç•¶ PackageResolver ç„¡æ³•æ‰¾åˆ°åŒ…æ™‚ï¼Œæœƒè‡ªå‹•æª¢æŸ¥ cache ä¸­æ˜¯å¦æœ‰åŒåè…³æœ¬ï¼š

  Err(_) => {
      // If not found as package, check if it's a script in cache
      if let Some(cached_script) = cache.find_script(name) {
          // Check platform support
          // Prepare for installation
      }
  }

  2. çµ±ä¸€çš„å®‰è£æµç¨‹

  é¡¯ç¤ºå¾…å®‰è£é …ç›®ï¼š
  Packages to install:
    â€¢ ripgrep v13.0.0 (new)

  Scripts to install:
    â€¢ my-script (PowerShell) (new)

  çµ±ä¸€ç¢ºèªæç¤ºï¼š
  Proceed with installation? [Y/n]

  3. install_script_from_bucket å‡½æ•¸ (766-814 è¡Œ)

  æ–°å¢å°ˆé–€è™•ç†å¾ bucket å®‰è£è…³æœ¬çš„å‡½æ•¸ï¼š
  - å¾ URL ä¸‹è¼‰è…³æœ¬å…§å®¹
  - èª¿ç”¨ç¾æœ‰çš„ install_script() é‚è¼¯
  - å‰µå»º shim/launcher
  - æ›´æ–° installed.json

  4. å®Œæ•´çš„ç¸½çµè¼¸å‡º

  Summary:
    âœ“ 2 package(s) installed
    âœ“ 1 script(s) installed

  ---
  ğŸ”„ å®Œæ•´å·¥ä½œæµç¨‹

  1. å‰µå»º bucket manifest

  {
    "packages": [
      { "name": "ripgrep", ... }
    ],
    "scripts": [
      {
        "name": "hello",
        "description": "Hello world script",
        "url": "https://raw.githubusercontent.com/user/repo/main/hello.ps1",
        "script_type": "powershell",
        "repo": "https://github.com/user/repo"
      }
    ]
  }

  2. æ·»åŠ  bucket

  wenget bucket add my-bucket https://example.com/manifest.json

  3. æœç´¢è…³æœ¬

  wenget search hello

  è¼¸å‡ºï¼š
  Scripts:
  NAME                 TYPE       DESCRIPTION
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  hello                PowerShell  Hello world script

  4. æŸ¥çœ‹è…³æœ¬ä¿¡æ¯

  wenget info hello

  è¼¸å‡ºï¼š
  hello [Script]
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Script type:     PowerShell
  URL:
  https://raw.githubusercontent.com/user/repo/main/hello.ps1
  Repository:      https://github.com/user/repo
  Description:     Hello world script
  Source:          Bucket (my-bucket)
  Status:          Not installed
  Current platform: Supported

  5. å®‰è£è…³æœ¬

  wenget add hello

  è¼¸å‡ºï¼š
  Scripts to install:
    â€¢ hello (PowerShell) (new)

  Proceed with installation? [Y/n] y

  Installing hello (PowerShell)...
    Downloading script from https://raw.githubusercontent.com/...
    Installing script as 'hello'...
    Creating launcher...
    âœ“ Installed successfully

  Summary:
    âœ“ 1 script(s) installed

  6. ä½¿ç”¨è…³æœ¬

  hello

  ---
  âœ… æ¸¬è©¦çµæœ

  - âœ… cargo check - é€šé
  - âœ… cargo build --release - é€šé
  - âœ… å®Œæ•´çš„å®‰è£æµç¨‹å¯¦ç¾
  - âœ… å‘å¾Œç›¸å®¹ç¾æœ‰åŠŸèƒ½

  ---
  ğŸ‰ å®Œæˆçš„å®Œæ•´åŠŸèƒ½éˆ

  1. âœ… Bucket manifest æ”¯æ´ scripts - SourceManifest æ“´å±•
  2. âœ… Cache ç³»çµ±æ”¯æ´è…³æœ¬ - ManifestCache æ“´å±•
  3. âœ… search æŒ‡ä»¤ - å¯æœç´¢è…³æœ¬
  4. âœ… info æŒ‡ä»¤ - å¯æŸ¥çœ‹è…³æœ¬è©³æƒ…
  5. âœ… add æŒ‡ä»¤ - å¯å¾ bucket å®‰è£è…³æœ¬

  ---
  ğŸ“Š æ¶æ§‹å„ªå‹¢

  - çµ±ä¸€ç®¡ç† - åŒ…å’Œè…³æœ¬åœ¨åŒä¸€å€‹ bucket ä¸­ç®¡ç†
  - ä¸€è‡´é«”é©— - ç›¸åŒçš„ search/info/add æŒ‡ä»¤
  - å¹³å°æª¢æŸ¥ - è‡ªå‹•æª¢æŸ¥è…³æœ¬å¹³å°æ”¯æ´
  - ä¾†æºè¿½è¹¤ - è¨˜éŒ„è…³æœ¬ä¾†è‡ªå“ªå€‹ bucket
  - å‘å¾Œç›¸å®¹ - å®Œå…¨ä¸å½±éŸ¿ç¾æœ‰åŠŸèƒ½

  ç¾åœ¨ wenget å·²ç¶“å®Œå…¨æ”¯æ´å¾ bucket ç®¡ç†å’Œå®‰è£è…³æœ¬äº†ï¼ ğŸ‰

> 1.æ›´æ–°ç‰ˆè™Ÿ0.5.0 2.æ›´æ–°æ–‡ä»¶ 3.æ‰“tagåŠ0.4.0->0.5.0çš„release note 4.æ¨é€æ›´æ–° 

â— å¥½çš„ï¼æˆ‘ä¾†åŸ·è¡Œé€™äº›ä»»å‹™ã€‚è®“æˆ‘å…ˆè¦åŠƒä¸€ä¸‹ï¼š

â— æ­¥é©Ÿ 1ï¼šæ›´æ–°ç‰ˆè™Ÿåˆ° 0.5.0

â— Read(Cargo.toml)
  â¿ Â Read 61 lines

â— Update(Cargo.toml)
  â¿ Â Updated Cargo.toml with 1 addition and 1 removal                  
       1    [package]
       2    name = "wenget"
       3 -  version = "0.4.0"
       3 +  version = "0.5.0"
       4    edition = "2021"
       5    authors = ["wen"]
       6    description = "A cross-platform package manager for GitHub 
           binaries"

â— æ­¥é©Ÿ 2ï¼šæ›´æ–° README.md

â— Read(README.md)
  â¿ Â Read 100 lines

â— Update(README.md)
  â¿ Â Updated README.md with 4 additions and 2 removals                   
        8    
        9    - **ğŸš€ One-line Installation**: Remote installation scripts 
            for quick setup
       10    - **ğŸ”„ Auto-update**: Always installs the latest version 
            from GitHub Releases
       11 -  - **ğŸ“¦ Bucket System**: Organize packages 
          -  using bucket manifests
       11 +  - **ğŸ“¦ Bucket System**: Organize packages and scripts 
          +  using bucket manifests
       12 +  - **ğŸ“œ Script Support**: Install and manage PowerShell, 
          + Bash, and Python scripts from buckets
       13    - **ğŸŒ Cross-platform**: Windows, macOS, Linux (multiple 
            architectures)
       14    - **ğŸ“ Organized Storage**: All packages in `~/.wenget/` 
            with proper structure
       15 -  - **ğŸ” Smart Search**: Search packages 
          -  across all configured buckets
       15 +  - **ğŸ” Smart Search**: Search packages and scripts 
          +  across all configured buckets
       16    - **âš¡ Fast Downloads**: Multi-threaded downloads with 
            caching
       17    - **ğŸ¯ Platform Detection**: Automatically selects the 
            correct binary for your system
       18 +  - **ğŸ”§ Smart Command Naming**: Automatically removes 
          + platform suffixes from executable names
       19    
       20    ## Quick Install
       21    

â— Read(README.md)
  â¿ Â Read 100 lines

â— Update(README.md)
  â¿ Â Updated README.md with 24 additions and 6 removals                  
       121    
       122    ## Bucket System
       123    
       124 -  Buckets are collections of package 
           -  manifests hosted online. The official Wenget bucket 
           -  provides curated open-source tools.
       124 +  Buckets are collections of package and script 
           +  manifests hosted online. The official Wenget bucket 
           +  provides curated open-source tools.
       125    
       126    ### Official Bucket
       127    
     ...
       131    
       132    ### Creating Your Own Bucket
       133    
       134 -  You can create custom buckets to distribute your own 
           -  package collections. See the [official Wenget bucket 
           -  repository](https://github.com/superyngo/wenget-bucket) for
           -   a complete example.
       134 +  You can create custom buckets to distribute your own 
           +  package and script 
           +  collections. See the [official Wenget bucket 
           +  repository](https://github.com/superyngo/wenget-bucket) for
           +   a complete example.
       135    
       136    #### Bucket Structure
       137    
     ...
       139    
       140    ```json
       141    {
       142 -    "name": "my-bucket",
       143 -    "description": "My custom bucket",
       144 -    "version": "1.0.0",
       142      "packages": [
       143        {
       144          "name": "my-tool",
       145 -        "repo": "username/repo",
       145 +        "repo": "https://github.com/username/repo",
       146          "description": "Tool description",
       147          "homepage": "https://example.com",
       148 +        "license": "MIT",
       149 +        "platforms": {
       150 +          "windows-x86_64": {
       151 +            "url": "https://github.com/username/repo/releases
           + /download/v1.0.0/tool-windows-x64.zip",
       152 +            "size": 1234567
       153 +          },
       154 +          "linux-x86_64": {
       155 +            "url": "https://github.com/username/repo/releases
           + /download/v1.0.0/tool-linux-x64.tar.gz",
       156 +            "size": 1234567
       157 +          }
       158 +        }
       159 +      }
       160 +    ],
       161 +    "scripts": [
       162 +      {
       163 +        "name": "my-script",
       164 +        "description": "Useful script",
       165 +        "url": "https://raw.githubusercontent.com/username/re
           + po/main/script.ps1",
       166 +        "script_type": "powershell",
       167 +        "repo": "https://github.com/username/repo",
       168 +        "homepage": "https://example.com",
       169          "license": "MIT"
       170        }
       171      ]

â— Update(README.md)
  â¿ Â Updated README.md with 16 additions and 9 removals           
       174    
       175    #### Required Fields
       176    
       177 -  - `name`: Unique bucket identifier
       178 -  - `description`: Brief description of the bucket
       179 -  - `packages`: Array of package definitions
       180 -    - `name`: Package name (used in commands)
       181 -    - `repo`: GitHub repository in `owner/repo` format
       182 -    - `description`: Brief package description
       177 +  **For Packages:**
       178 +  - `name`: Package name (used in commands)
       179 +  - `repo`: GitHub repository URL
       180 +  - `description`: Brief package description
       181 +  - `platforms`: Platform-specific binary information
       182 +    - `url`: Download URL for the binary
       183 +    - `size`: File size in bytes
       184    
       185 +  **For Scripts:**
       186 +  - `name`: Script name (used in commands)
       187 +  - `description`: Brief script description
       188 +  - `url`: Direct URL to the script file
       189 +  - `script_type`: Script type (`powershell`, `bash`, 
           + `batch`, or `python`)
       190 +  - `repo`: Repository URL (for reference)
       191 +  
       192    #### Optional Fields
       193    
       194 -  - `version`: Bucket version (for tracking updates)
       194    - `homepage`: Project homepage URL
       195 -  - `license`: Package license
       196 -  - `tags`: Array of tags for categorization
       195 +  - `license`: Package/script license
       196 +  - `checksum`: SHA256 checksum for verification
       197    
       198    #### Hosting Your Bucket
       199    

â— æ­¥é©Ÿ 3ï¼šå‰µå»º Release Notes

â— Write(RELEASE_NOTES_v0.5.0.md)
  â¿ Â Wrote 1 lines to RELEASE_NOTES_v0.5.0.md                              
     # Release Notes - v0.5.0
     ## ğŸ‰ Major Features
     ### ğŸ“œ Bucket Script Support
     Wenget now supports installing and managing scripts directly from
     bucket manifests! You can now distribute PowerShell, Bash, Batch, and
     Python scripts alongside binary packages.
     **Key Features:**
     - âœ… Install scripts from buckets with `wenget add <script-name>`

â— æ­¥é©Ÿ 4ï¼šæäº¤æ‰€æœ‰ä¿®æ”¹

â— Bash(git status)
  â¿ Â On branch main                               
     Your branch is up to date with 'origin/main'.
     â€¦ +30 lines (ctrl+o to expand)

â— Bash(git add -A && git status)
  â¿ Â On branch main                               
     Your branch is up to date with 'origin/main'.
     â€¦ +48 lines (ctrl+o to expand)

â— Bash(git commit -m "feat: v0.5.0 - Bucket script support and smart command
      namingâ€¦)
  â¿ [main df81a63] feat: v0.5.0 - Bucket script support and smart command n
    aming
     22 files changed, 2707 insertions(+), 531 deletions(-)
    â€¦ +9 lines (ctrl+o to expand)


â— æ­¥é©Ÿ 5ï¼šæ‰“ tag v0.5.0

â— Bash(git tag -a v0.5.0 -m "Release v0.5.0â€¦)
  â¿ Â (No content)

â— Bash(git tag -l "v0.5.0" && git show v0.5.0 --no-patch)
  â¿ Â v0.5.0                                 
     tag v0.5.0
     Tagger: superyngo <superyngo@gmail.com>
     â€¦ +71 lines (ctrl+o to expand)

â— æ­¥é©Ÿ 6ï¼šæ¨é€åˆ°é ç«¯

â— Bash(git push && git push --tags)
  â¿ Â To https://github.com/superyngo/Wenget.git
        98fa88d..df81a63  main -> main
     To https://github.com/superyngo/Wenget.git
      * [new tag]         v0.5.0 -> v0.5.0

â— âœ… æ‰€æœ‰ä»»å‹™å®Œæˆï¼v0.5.0 ç™¼å¸ƒæˆåŠŸ

  ğŸ“‹ å·²å®Œæˆçš„ä»»å‹™

  1. âœ… æ›´æ–°ç‰ˆè™Ÿ - Cargo.toml æ›´æ–°åˆ° 0.5.0
  2. âœ… æ›´æ–°æ–‡ä»¶ - README.md æ·»åŠ è…³æœ¬æ”¯æ´èªªæ˜
  3. âœ… å‰µå»º Release Notes - RELEASE_NOTES_v0.5.0.md
  4. âœ… æäº¤ä¿®æ”¹ - Commit: df81a63
  5. âœ… æ‰“ Tag - v0.5.0 æ¨™ç±¤å·²å‰µå»º
  6. âœ… æ¨é€æ›´æ–° - å·²æ¨é€åˆ° GitHub

  ---
  ğŸ‰ ç™¼å¸ƒè³‡è¨Š

  ç‰ˆæœ¬ï¼š v0.5.0
  æäº¤ï¼š df81a6332c4fb892be6893d1e7d3f98515329123
  æ¨™ç±¤ï¼š v0.5.0
  é ç«¯ï¼š https://github.com/superyngo/Wenget

  ---
  ğŸ“ ä¸»è¦è®Šæ›´

  æ–°åŠŸèƒ½

  1. Bucket è…³æœ¬æ”¯æ´ ğŸ“œ
    - æ”¯æ´å¾ bucket å®‰è£ PowerShellã€Bashã€Batchã€Python è…³æœ¬
    - çµ±ä¸€çš„ search/info/add æŒ‡ä»¤
    - è‡ªå‹•å¹³å°ç›¸å®¹æ€§æª¢æŸ¥
  2. æ™ºæ…§æŒ‡ä»¤å‘½å ğŸ”§
    - è‡ªå‹•ç§»é™¤å¹³å°å¾Œç¶´ï¼ˆå¦‚ cate-windows-x86_64.exe â†’ cateï¼‰
    - ä¿ç•™å¤šè©å·¥å…·åç¨±ï¼ˆå¦‚ git-lfsï¼‰
    - å¯ç”¨ --name åƒæ•¸è¦†è“‹

  æ ¸å¿ƒæ”¹é€²

  - æ“´å±•è³‡æ–™çµæ§‹æ”¯æ´è…³æœ¬
  - æ›´æ–° cache ç³»çµ±
  - å¢å¼· search/info/list æŒ‡ä»¤
  - å®Œå…¨å‘å¾Œç›¸å®¹

  ---
  ğŸ“Š è®Šæ›´çµ±è¨ˆ

  22 files changed
  2707 insertions(+)
  531 deletions(-)

  æ–°å¢æ–‡ä»¶ï¼š
  - RELEASE_NOTES_v0.5.0.md
  - src/installer/script.rs

  æ›´æ–°æ–‡ä»¶ï¼š
  - Cargo.toml (ç‰ˆæœ¬ â†’ 0.5.0)
  - README.md (æ·»åŠ è…³æœ¬æ”¯æ´æ–‡ä»¶)
  - src/cache.rs (è…³æœ¬ cache æ”¯æ´)
  - src/commands/add.rs (å¾ bucket å®‰è£è…³æœ¬)
  - src/commands/search.rs (æœç´¢è…³æœ¬)
  - src/commands/info.rs (é¡¯ç¤ºè…³æœ¬ä¿¡æ¯)
  - src/core/manifest.rs (ScriptItem çµæ§‹)
  - src/installer/extractor.rs (æ™ºæ…§å‘½å)
  - åŠå…¶ä»–ç›¸é—œæ–‡ä»¶

  ---
  ğŸ”— ä¸‹ä¸€æ­¥

  GitHub Release æœƒè‡ªå‹•è§¸ç™¼ï¼š
  - âœ… Tag å·²æ¨é€ (v0.5.0)
  - ğŸ¤– GitHub Actions å°‡è‡ªå‹•æ§‹å»ºä¸¦ç™¼å¸ƒ Release
  - ğŸ“¦ Release å°‡åŒ…å«æ‰€æœ‰å¹³å°çš„äºŒé€²åˆ¶æ–‡ä»¶

  æŸ¥çœ‹ Releaseï¼š
  https://github.com/superyngo/Wenget/releases/tag/v0.5.0

  ---
  ğŸŠ ç™¼å¸ƒå®Œæˆï¼

  v0.5.0 å·²æˆåŠŸç™¼å¸ƒåˆ° GitHubï¼GitHub Actions
  å°‡è‡ªå‹•æ§‹å»ºæ‰€æœ‰å¹³å°çš„äºŒé€²åˆ¶æ–‡ä»¶ä¸¦å‰µå»º Releaseã€‚

  æ‚¨å¯ä»¥åœ¨ GitHub ä¸ŠæŸ¥çœ‹ï¼š
  - Commits: https://github.com/superyngo/Wenget/commits/main
  - Tags: https://github.com/superyngo/Wenget/tags
  - Releases: https://github.com/superyngo/Wenget/releases



